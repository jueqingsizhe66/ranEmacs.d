星期六, 2018/2/3


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 09:45 Match with $#-                                               :perl:


#+BEGIN_SRC perl

  $x = "Mmm...donut, thought Homer";
  $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/;    # matches
  print "Match $#- positions\n";

  # foreach $exp (1..$#-) {
  #     print "Match $exp: '${$exp}' at position ($-[$exp],$+[$exp])\n";
  # }
  #

  foreach my $expr ( 1 .. $#- ) {
      printf "Match %s: '%s' at position (%d, %d)\n",
        $expr, substr( $x, $-[$expr], $+[$expr] - $-[$expr] ),   # fixes the error
        $-[$expr], $+[$expr];
  }

  if ( my @matches = $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/ ) {
      unshift @matches => undef;
      foreach my $expr ( 1 .. $#- ) {
          print
            "Match $expr: '$matches[$expr]' at position ($-[$expr],$+[$expr])\n";
      }
  }

  ""
#+END_SRC



** 09:52 Perl [] and {} , important {}                                :perl:

标量rerence的运用

#+BEGIN_SRC perl
  my $x;
  my $exp;
  for ( my $i = 0 ; $i < 10 ; $i++ ) {
      print "\$$i = $i\n";
  }

  for my $i ( 1 .. 10 ) {
      print "$i\n";
  }

  my $aref = [
      [ "fred",   "barney", "pebbles", "bambam", "dino", ],
      [ "homer",  "bart",   "marge",   "maggie", ],
      [ "george", "jane",   "elroy",   "judy", ],
  ];

  print $aref->[2]->[2], "\n";
  print $aref->[2][2], "\n";


  $aref = [3,4,5,6]; ## autovivification
  @arr = (1,2,3,4);
  $aref=\@arr;
  $aref = [@arr]

  $href= { 1=> 'one'
               2=>'two'}; ### autovivification
  @array = @{$aref}
  %hash =  %{$href}
  @keys  =  keys %{$href};

  Instead of ${$aref}[0] -----> $aref->[0]
             ${$href}{$key} --> $href0>{$key}
#+END_SRC


** 09:59 perl statistics                                              :perl:


#+BEGIN_SRC perl
  use strict;
  use warnings;
  use utf8;
  use Data::Dumper;

  my	$STATI_file_name = 'statistic.dat';		# input file name

  my	%total_bytes;
  open  my $STATI, '<', $STATI_file_name
      or die  "$0 : failed to open  input file '$STATI_file_name' : $!\n";


  while ( <$STATI> ) {

      my  ($source,$destination,$bytes)   = split;##按照空格划分
      $total_bytes{$source}{$destination}+=$bytes;## 累加
  }

  print Dumper(\%total_bytes),"\n";



  foreach my $source ( sort keys %total_bytes ) {

      foreach my $destination (sort keys %{$total_bytes{$source}} ) {
          print "$source => $destination:", "$total_bytes{$source}{$destination} bytes \n";
      }
  }
  close  $STATI
      or warn "$0 : failed to close input file '$STATI_file_name' : $!\n";


#+END_SRC


statistics.dat------------------------->


#+BEGIN_SRC org
  professor.hut gilligan.crew.hut 1250
  professor.hut lovey.howell.hut 910
  thurston.howell.hut lovey.howell.hut 1250
  professor.hut lovey.howell.hut 450
  professor.hut laser3.copyroom.hut 2924
  ginger.girl.hut professor.hut 1218
  ginger.girl.hut maryann.girl.hut 199

#+END_SRC


** 10:02 perl sort                                                    :perl:


#+BEGIN_SRC perl

  ##alphabetically
  my @nums = sort qw/1 2 11 22 10 100/;
  print "Empty: @nums\n";

  my @nums2 = sort { $b cmp $a } qw/1 2 11 22 10 100/;
  print "CMP: @nums2\n";

  my @nums3 = sort { $a cmp $b } qw/1 2 11 22 10 100/;
  print "CMP: @nums3\n";

  ## numerically
  my @nums1 = sort { $a <=> $b } qw/1 2 11 22 10 100/;
  print "Numerically: @nums1\n";

  ## numerically2

  my @num2 = sort compare qw/1 2 11 22 10 100/;
  print "Subroutine: @num2\n";

  sub compare {
      if ( $a < $b ) {
          return -1;
      }
      elsif ( $a == $b ) {
          return 0;
      }
      else {
          return 1;
      }

  }

  ## objectically

#+END_SRC


** 10:04 access people with perl(first cols, then get data from files) :perl:


#+BEGIN_SRC perl
  use strict;
  use warnings;
  use utf8;

  my @records;
  my @cols = ( 's_name', 'f_name', 'job' ); ##列名

  my $FILE_file_name = 'people.dat';    # output file name

  open my $FILE, '<', $FILE_file_name
    or die "$0 : failed to open  output file '$FILE_file_name' : $!\n";
  while (<$FILE>) {
      chomp;
      my %rec;
      @rec{@cols} = split /,/;## split with comma(csv file format)
      push @records, \%rec; ### push into records
  }

  close $FILE
    or warn "$0 : failed to close output file '$FILE_file_name' : $!\n";

  foreach (@records) {
      print "$_->{f_name} ", "$_->{s_name} ", "is a $_->{job}\n";
  }


#+END_SRC



#+BEGIN_SRC people.dat
  Jones, Martha, UNIT
   Harkness,JACK,Torchwood
   Smith,Sarah Jane, Journalist

#+END_SRC

** 10:07 grade statistics                                              :perl:

grade tables:


#+BEGIN_SRC org
  Ben 76
  Clementine 49
  Norm 66
  Chris 25
  Doug 35
  Carol 35
  Ben 12
  Clementine 02
  Norm 65


  Norm 33


  Funny 34

#+END_SRC



#+BEGIN_SRC perl

  use strict;
  use warnings;
  use utf8;

  my  $student;
  my  $grade;

  my	%grades;

  my  $scores   = 0;
  my  $total   = 0;
  my  @gradeOf  ;
  my  $line;
  my  $average;


  my	$GRADES_file_name = 'grade.dat';		# input file name

  open  my $FG, '<', $GRADES_file_name
      or die  "$0 : failed to open  input file '$GRADES_file_name' : $!\n";


  while ( $line = <$FG>) {
      next if $line =~ m/^\s*$/g; ### 空行跳出 不进行parse
      chomp($line); ## delete the return symbol
      ($student, $grade) = split(" ", $line);
      $grades{$student} .= $grade . " ";
  }


  foreach my $line ( sort keys %grades ) {
      print "$line => $grades{$line}\n";
  }

  foreach my $student1 ( sort keys %grades  ) {
      my  $scores   = 0;
      my  $total   = 0;
      my  @gradeOf   = split(" ",$grades{$student1});


      foreach my $grade ( @gradeOf ) {
            $total +=$grade;
            $scores++;
      }
      $average = $total / $scores;
      print "$student1: $grades{$student1} \t Average: $average\n";
  }

  close  $FG
      or warn "$0 : failed to close input file '$GRADES_file_name' : $!\n";

#+END_SRC



** 11:17 git stash                                                     :git:



#+BEGIN_SRC sh
  git stash
        git stash save newStashName  也可以取个名字

  git stash list

  git stash apply  从栈顶弹出，（堆栈中依然存在）

  git stash pop  从堆栈中弹出stash（堆栈中不存在了）


  git stash clear  删除所有

  git stash drop stashname  删除制定的stash
#+END_SRC
