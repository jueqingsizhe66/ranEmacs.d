* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 16:16 yes it works

** 16:22 dynamic characterization of multi-axis 

** 
## 20171010 -----------------------------------
星期二, 2017/10/10


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 12:24 FYI :For your information
FYI用 户 信 息,供参考For your Information的 缩 写, 是 一 种 寻 求 用 普 通 英 语 说 明Internet标 准 和 技 术 的 电 子 出 版 系 列, 与RFC(请 求 注 释)一 样 的 方 式 分 发, 但FYI的 意 图 与RFC不 同, 并 不 是 为 了 建 立 新 的 标 准. 在Usenet和 电 子 邮 件 中,FYI通 常 作 为 在 讨 论 中 供 你 使 用 的 信 息 的 缩 写.
PLS:please
Pls noted as mail subject 请注意邮件主题

** 
## 20171011 -----------------------------------
星期三, 2017/10/11


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 23:25 I found out about this diatribe as I sat down to spend the day (my weekend) continuing to work for the Clojure ecosystem. Time spent in lieu of spending time with my wife, having already spent the work week on spec, my Conj talk, and the Clojure 1.9 release.

I don't believe diatribes such as these deserve attention, but, to the extent they foster misconceptions, they do harm that must be addressed.

Cognitect does not make money from Clojure. Period. We want the same things from/for Clojure as other businesses using it - stability and quality. Absolutely no decisions are made regarding Clojure that impact our revenues because we have no revenue from Clojure itself whatsoever. We spend money on Clojure (i.e. paying a non-billable salary so Alex Miller can support the community and the language) because we rely upon it and want it to thrive. We don't make money from Clojure conferences. I personally am over $200k in the negative overall due to my initial work on Clojure. Money I have no prospects of getting back. Not that that is anyone else's business, but anyone sitting around thinking Cognitect or I am making money on Clojure is mistaken.

Lots of great people work for Cognitect, it's true. And what makes them great is primarily the fact that they are really good people. People too nice to respond to such diatribes in kind. Makers. And givers - there's not a person at Cognitect who wouldn't freely give you their time and best advice if you sought their help, who haven't given their time speaking at user groups, and building open-source tools and libraries, writing books, sharing their knowledge and investing their spare time acquiring it. They don't make money off Clojure, they make money through their ongoing effort writing new software to solve customer problems, or by making Datomic for companies that still value software enough to pay for it. Cognitect is not 'the establishment', it's a small company that provides a livelihood and healthy nurturing culture for those that work here. No one is getting rich.

This consistent sense of entitlement to the efforts of makers, amongst a community of supposed makers, is baffling and counterproductive. It is a cancer of the software development community at large and will inevitably lead to the devaluation of software and those who make it, and has already.

I've done months of design work on the next phase of spec, and we have an agenda to take on implementing that after the 1.9 release and Conj. It is astounding to see something like spec characterized as an attack on another library or abnegation of the community. I've invested about 9 months of my life on spec, for which I and Cognitect will never see a dime, and am open-sourcing my effort. And this is the response? With spec, I was just pursuing what I thought was a good idea (as was Luke with Arachne). That can't become wrong due to some supposed community obligation or we'll never have novelty.

The posts asks "On Whose Authority?" but doesn't use the word again.

Here's what 'authority' means (from dictionary.com):

"from Latin auctoritatem (nominative auctoritas) "invention, advice, opinion, influence, command," from auctor "master, leader, author" (see author (n.))"

and 'author':

"literally "one who causes to grow," agent noun from auctus, past participle of augere "to increase" (see augment)"

Thus authority comes along with authorship, and is accorded first to the makers, people who've added to the world. I don't know why that is no longer obvious. Thinking otherwise yields a broken economic model, where people are not entitled to control over the products of their own labor, and thus are without control over their livelihood.

Clojure was not originally primarily a community effort, and it isn't primarily one now. That has to be ok. The presumption that everything is or ought to be a community endeavor is severely broken. A true community respects the autonomy of its participants, else it degenerates into a cult of need/want.

Cognitect is a terrific supporter of Clojure, and happens to be where I work, but the ultimate authority and stewardship of Clojure remains with me and I am responsible for the decisions governing it, good or bad.

To those who think that Datomic ought to be open source: We don't see a viable economic model there. If you think otherwise, come up with the money to buy the IP and make a go of it. If you can't, then recognize your arguments for the hot air of entitlement they are.

We can argue about the software economy and open source models all day. In the end it's about people. You can't say f**k XYZ and deny that it is an attack on the people who work on XYZ. Cognitect is not some evil corporate entity, it's a bunch of people with families trying to make a living, pay their mortgages and send their kids to college. And, if you are talking about Clojure, you are talking to me. The indirection doesn't mask the attack on people, their work and their choices.

I have to say now to those for whom such expressions are cathartic - they hurt people, a lot. I don't believe the sentiments in the post are widely held - most people who are happily using Clojure aren't as vocal. But it doesn't take many arrows to bring someone down.

Every time I have to process such a diatribe and its aftermath, and its effects on myself, my family, and my co-workers, I have to struggle back from "Why should I bother?", and every time it gets harder to justify to myself and my family that it's worth the time, energy and emotional burden. Every time a community engages with such a diatribe without calling it out, and decrying its tone, the civility of our discourse and treatment of others heads further down the drain. It's time for people who value other people to speak out, in this domain and elsewhere:

Chris Zheng, your diatribe is despicable. Your post demonstrates a lack of respect for people, their hard work, their contributions, their independence, and their economic, social and familial responsibilities. Grow up.

    永久連結embed檢舉

[–]Borkdude 44 指標 3 天前* 

Well said Rich. I'm very grateful for all the hard work you and Cognitect put into Clojure. I and other people should probably say this out loud more often.

    永久連結embed上層留言檢舉

[–]zcaudate[S] -1 指標 2 天前* 

@Borkdude. I will have to leech off of your good sentiments to Rich because my reply dropped off the thread due to negative votes.

I personally don't mind negativity. I do think that populist sentiment does little to address the problem that I want this thread to self-reference: When Rich and other members of the Cognitect community poopoos something, the community is also given the 'authoritative reference' to poopoo.

This was reflected in how the Reddit thread changed before and after Rich replied. He is a rockstar, there's no doubt about that.

Midje was a great project but it has pretty much died and one of the reasons was that there was a reluctance from the core to say anything positive about it. https://groups.google.com/forum/#!topic/clojure/T8fIW27kDYE

In the end, it's about intent. My intent stands on solid foundation and I'm happy to be mocked/blasted/challenged. They say that the ultimate fear of ambition is to be held in obscurity. I welcome all.

    永久連結embed上層留言檢舉

[–]alexelcu 5 指標 2 天前 

    I personally don't mind negativity. I do think that populist sentiment does little to address the problem that I want this thread to self-reference

It's probably because you haven't received much negativity, plus your personal opinion on this is irrelevant when other people are clearly getting hurt. I'm also an open source software author, interacting with other software makers and I can relate to Rich's pain here.

Programming in general isn't a science. Much like math, a big part of programming is communication and collaboration. You might classify this response as a "populist sentiment", however by phrasing your opinions in the disrespectful way that you did, it's pretty obvious that you're not looking for a dialog, so you shouldn't be surprised if you're not getting one.

    This was reflected in how the Reddit thread changed before and after Rich replied.

That's because people on the Internet tend to be really mean under the cover of anonymity. Just like when you are in traffic and feel the need to honk loudly or swear at other people for not moving at the green light in a split second, things you would never do when face to face out of fear of being punched.

That Rich Hickey tempered the thread, that's not because he's a "rockstar", but because he reminded people of the personal sacrifices he and others are making.

    Midje was a great project but it has pretty much died.

I've never seen Midje, but reading that thread I do see many counter points I agree with. For example I also think that "mocking" is a serious code smell and should never happen, unless the code is too tightly coupled with side effects. The solution IMO shouldn't be to provide better tools for mocking, but to encourage architectures that don't need mocking at all.

But anyway, there are many reasons for why open source projects live or die and I'm pretty sure that you're oversimplifying the issue. I've been working on Monix since 2014, a project whose popularity rose only in the last year and a half. And for that to happen, I had to go at conferences to teach people about it, I had to be super responsive on its Gitter channel, literally helping all new users with their problems, I had to keep developing it, adding new features in response to competition, I had to make it play nice with other libraries in the ecosystem, etc.

Projects don't win just on technical merits, but also on finding a product-market fit, on marketing and on collaboration, a painful truth that many of us ignore because this requires soft skills many of us don't possess.

    In the end, it's about intent. My intent stands on solid foundation and I'm happy to be mocked/blasted/challenged. They say that the ultimate fear of ambition is to be held in obscurity. I welcome all.

No, in the end it's about being able to work with others in order to deliver products and being an ambitious dick is nothing to be proud of.

    永久連結embed上層留言檢舉

[–]zcaudate[S] 2 指標 2 天前 

    being an ambitious dick is nothing to be proud of.

pride is never a good thing.

    永久連結embed上層留言檢舉

[–]ReflectiveTeaTowel 1 指標 5小時前 

Patently bollocks. Having pride in your work means you give a shit if it's good or not

    永久連結embed上層留言檢舉

[–]grammati 58 指標 3 天前 

Rich, I am in my office giving this reply a standing ovation. I firmly believe that 99.9% of the Clojure community is doing the same.

Remember that for every whining malcontent that posts nonsense like this, there are 1000 happy, productive Clojure programmers. I am one of them. I have worked with many others. We are out here, quietly writing software, creating things, and enjoying every minute of it. You may not hear much from us; most of us don't blog, or comment on Reddit. But please know that we, the silent majority, are deeply grateful for the years of hard work that you and others have put into Clojure. Thank you.

    永久連結embed上層留言檢舉

[–]zcaudate[S] -3 指標 2 天前* 

It's not about 'content' vs 'malcontent'. Please don't have 'us' vs 'them' blinders on the topic. I'm one person sharing my own experience - both the good and the bad. When posts such as these gets labelled as 'diatribe' and put into the 'reject' basket, it does not bring anything new to the table.

    永久連結embed上層留言檢舉

[–]umpc 3 指標 2 天前 

I only had to read a single line.

    ...Fuck Clojure.

Yup. It's a diatribe.

Not only that, it is a definitive example of one. There is no ambiguity as to whether or not it even is one. Who cares what the rest of it even says?

You purposely disrespected the people who gave up and give up their limited time to develop Clojure, so fuck your opinion. :)

    永久連結embed上層留言檢舉

[–]zcaudate[S] 0 指標 2 天前 

Thanks for taking the time out of your hectic schedule to give me your thoughts on how to pick out a diatribe.

    永久連結embed上層留言檢舉

[–]Michaelmrose 2 指標 2 天前 

You didn't even present coherent complaints. Nothing you whined about made sense. Why don't you quit while you are behind?

    永久連結embed上層留言檢舉

[–]zcaudate[S] -2 指標 2 天前 

@michaelmrose: one word. wow.

    永久連結embed上層留言檢舉

[–]gorrepati 25 指標 3 天前 

Clojure is a big reason why I fell in love with programming again. I feel your (and your colleagues) efforts are thoroughly appreciated by many a people like me, albeit silently.

The thing is, there are a lot of smart people in the world without good taste. Even though the things they do work, they place a lot of unseen mental burden on us lesser programmers. Please please be aware that there are lot of discerning (but may not be capable) engineers like us, who appreciate the time, work and emotional energy you put into it.

I haven't grown up with a Apple computer as a kid; never seen it until I was an adult. I distinctly remember my heart leaping in joy the first time I used it. I had the same feeling when I first came to Clojure. That is the highest praise I can give to someone who sweat, fought against status quo and raised the standards for everyone else. Thank you so very much!

    永久連結embed上層留言檢舉

[–]yogthos 10 指標 3 天前 

Thank you for all the work you've done on Clojure, it is very much appreciated.

    永久連結embed上層留言檢舉

[–]daemianmack 23 指標 3 天前 

Thanks for the clarity above, Rich, and moreover: thank you for so carefully designing and stewarding Clojure.

    永久連結embed上層留言檢舉

[–]I_am_a_haiku_bot 1 指標 3 天前 

Thanks for the clarity above,

Rich, and moreover: *thank you for so*

carefully designing and stewarding Clojure.

-english_haiku_bot

    永久連結embed上層留言檢舉

[–]ertucetin 15 指標 3 天前 

Well said, he needs to grow up!

    永久連結embed上層留言檢舉

[–]ferociousturtle 16 指標 3 天前 

    Every time I have to process such a diatribe and its aftermath, and its effects on myself, my family, and my co-workers, I have to struggle back from "Why should I bother?", and every time it gets harder to justify to myself and my family that it's worth the time, energy and emotional burden.

Man. I'm sorry to hear this. Clojure is a beautiful language. It's easily my favorite language. The hard work you have put into it, and especially the hard work you've put into saying no to additional complexity and keeping the core small... Well, there are a whole lot of folks who appreciate it and probably don't tell you that often enough.

I hope you continue to bother for a very long time.

    永久連結embed上層留言檢舉

[–]un_passant 12 指標 3 天前 

Just taking the opportunity of your post to thank you for all the work you put into making this awesome gift that is Clojure !

    永久連結embed上層留言檢舉

[–]Owengjones 12 指標 3 天前 

Thank you Rich. And thank you, Alex, Cognitect and the entire community for Clojure. I assume there are many like me who happily use Clojure in drama-less silence everyday; maybe we need to speak up more.

    永久連結embed上層留言檢舉

[–]Naomarik 13 指標 3 天前 

    Every time I have to process such a diatribe and its aftermath, and its effects on myself, my family, and my co-workers, I have to struggle back from "Why should I bother?", and every time it gets harder to justify to myself and my family that it's worth the time, energy and emotional burden. Every time a community engages with such a diatribe without calling it out, and decrying its tone, the civility of our discourse and treatment of others heads further down the drain. It's time for people who value other people to speak out, in this domain and elsewhere.

I am one of silent happy clojure users. I am someone who can appreciate what the language can do after developing projects in others before.

Cognitect's work on clojure/script has given me the ability to execute on work that I would find impossible to do in languages I've used previously. All the work you guys do reading those 1970s research papers that are incomprehensible to me and implementing the ideas into clojure have had a massive impact in the life I have now. I'm not someone who zealously enjoys programming, I just enjoy being able to make a living creating things on my own schedule.

I'm extremely grateful for the work you put in. clojure.spec completely blew me away when I realized what it can do especially with generative testing. Datomic looks amazing and is on my todo list of things to learn properly but I'm still managing to move quickly without it on my current project.

If I look at other languages I just feel like everything is a complete mess. Please keep doing what you're doing. Having tasted clojure with one master chef who is very meticulous about what he's doing, nothing else is tempting.

I'm looking forward to your next talk, Rich.

    永久連結embed上層留言檢舉

[–]joncampbelldev 9 指標 3 天前 

Well said. As one of the usually less vocal but happy people I'd like to say thank you, clojure has given me a significant boost in happiness (and efficiency) at my job and in my hobby projects.

Also I can't help but smile that you go to the original definition of a word in anger as well as in conference talks.

    永久連結embed上層留言檢舉

[–]aisamu 8 指標 3 天前 

Thank you, Rich.

For Clojure, for Datomic, for your wonderful talks.

    永久連結embed上層留言檢舉

[–]mobiledevguy5554 4 指標 2 天前* 

Rich the silent majority greatly appreciates and respects the efforts of you and your team in building out this incredible ecosystem. I personally can’t wait to find a reason to buy a license for your database. I no longer just thank folks providing these wonderful open source projects, I pay them on patreon or some other service.

Guys like you, Rob Pike, Anders h, Alan kay, the list goes on and on are my personal heroes (and I’m 50!). While I can’t operate at your level, your writings and talks inspire me to always keep improving always getting better.

    永久連結embed上層留言檢舉

[–]bit_cmdr 6 指標 3 天前 

‪I really appreciate all the work that you & Cognitect have put into Clojure. I admire your stewardship of the language and your passion for it. It’s one of the things that draws me towards Clojure. Personally, I have found Clojure and the Clojure community to be one of the more welcoming and friendly ecosystems. Clojure and its community continue to be my favorite. Don’t let a few bad apples spoil the bunch. Thank you and all involved.

    永久連結embed上層留言檢舉

[–]deafmacro 5 指標 3 天前 

Thank you for Clojure. It is a piece of art!

    永久連結embed上層留言檢舉

[–]theothagod 6 指標 3 天前 

Clojure is amazing! Thank you Rich. Please keep it amazing forever!

    永久連結embed上層留言檢舉

[–]dansjay 5 指標 3 天前 

With giving us Clojure you made us believe that we are hackers, problem solvers and a strong community, who are crazy enough to take the risk for what we believe in. Thank you for bothering to address this post. We are looking forward to the Clojure 1.9 release and specially to your next Conj talk sir.

    永久連結embed上層留言檢舉

[–]the2bears 5 指標 2 天前 

After toiling for years in Java, and slowly losing any passion for software, Clojure was responsible for helping me regain it. Thank-you for that.

    永久連結embed上層留言檢舉

[–]the_evergrowing_fool 6 指標 3 天前* 

    Clojure was not originally primarily a community effort, and it isn't primarily one now.

This is arguably the best part of Clojure.

The worst part...the zealots in this community.

    永久連結embed上層留言檢舉

[–]afmoreno 2 指標 2 天前 

Rich,

You like words--thought I would give you the definition of Auctor from Peter Lombard's Libri Sententiarum:

The Method of making a book is fourfold. For someone writes the materials of others, adding and changing nothing, and this person is said to be merely the scribe [scriptor]. Someone else writes the materials of others, adding, but nothing of his own, and this person is said to be the compiler [compilator]. Someone else writes both the materials of other men, and of his own, but the materials of others as the principal materials, and his own annexed for the purpose of clarifying them, and this person is said to be the commentator [commentator], not the author [auctor]. Someone else writes both his own materials and those of others, but his own as the principal materials, and the materials of others annexed for the purpose of confirming his own, and such must be called the author [auctor].

I think of you and the core contributors as "authors" with the rest of the community in one of the other three roles. I like Clojure because I recognize the thoughtfulness behind the language: the "right" definition of literals, the "right" implementation of key Lisp features, the ecumenical approach towards being a hosted language, careful towers of abstraction, etc. I have invested learning Clojure because I believe it makes me smarter (per the quote that floats the ether) and also because it makes programming fun again. All my best to you and those who toil for our benefit. Thanks.

    永久連結embed上層留言檢舉

[–]zcaudate[S] 0 指標 2 天前 

@afmoreno: I'm curious if there's a metaphor in what you just wrote.

    永久連結embed上層留言檢舉

[–]afmoreno 1 指標 1 天前 

I thought the quote apt because it captures the idea that all software development consists of dwarfs standing on the shoulders of giants: Rich is that author of Clojure but his work stands on the foundation of the JVM, etc. Similarly, I think of library authors as "commentators", i.e., they add to the language but are minor players. Programmers tend to be "compilators": we poke around to find stuff that will work and we stitch it together, more often than not without a great deal of value-add. I think the analogy breaks down here.

Cheers!

    永久連結embed上層留言檢舉

[–]zcaudate[S] 1 指標 1 天前 

I love it. It does put things into perspective.

    永久連結embed上層留言檢舉

[–]dirtyvagabond 5 指標 3 天前 

Thank you Rich, for all that you do

    永久連結embed上層留言檢舉

[–]nathants 3 指標 3 天前 

thank you, rich.

    永久連結embed上層留言檢舉

[–]jwr 4 指標 2 天前 

    Every time I have to process such a diatribe and its aftermath, and its effects on myself, my family, and my co-workers, I have to struggle back from "Why should I bother?"

Rich, please do bother. Thanks to your work many other people (me included) are able to pay their bills and support their families. If it wasn't for Clojure and ClojureScript, I would not have been able to tame the complexity of my SaaS app, so I owe you quite a bit.

I've seen many of these types of rants about the "language" and "community" over the years. Most of the time they are written by people who do not write and maintain apps for a living. People that actually do write apps to support themselves tend to be rather quiet. They've got things to do, and they are grateful for the tools that others have provided.

I am in that "quiet" category most of the time, but now is the time to speak up and support what you're doing.

    永久連結embed上層留言檢舉

[–]neverfox 3 指標 2 天前* 

Another thank you, Rich. I have not only had the joy of using Clojure has my primary language (for work and play) but also the joy of teaching it to others and watching the epiphany that comes from using a powerful and simple functional language. It angers and frustrates me that things like this happen that threaten to undermine its future. I consider it a careless attack on my livelihood and the livelihood of those like me. It's personal for us too.

    永久連結embed上層留言檢舉

[–]surya_aditya 2 指標 3 天前 

Your efforts are highly appreciated Rich, it has had positive influence on the community, it is a great acheivement. thanks again.

    永久連結embed上層留言檢舉

[–]bpiel 2 指標 3 天前 

Thanks, Rich & Cognitect. I sincerely wish you were all getting rich.

    永久連結embed上層留言檢舉

[–]kingnuscodus 2 指標 2 天前 

Well said Rich..Thank You for your amazing work and for giving the world Clojure - which for me made programming fun again. It would be nice if the author of the post could write another with a formal apology - in the meantime, please know that the very vast majority of us will be forever grateful for your stewardship and many other contributions to the language!

    永久連結embed上層留言檢舉

[–]zcaudate[S] 1 指標 2 天前 

Let's hope that this dialectic will produce a more reasoned synthesis. Apologies are way too cheap by my reckoning.

    永久連結embed上層留言檢舉

[–]addamsson 1 指標 1 天前 

I'm a long time user and admirer of Clojure. I don't think that naysayers like this guy are worth addressing, but I see that if they reach a critical mass they must be put to their place.

On the other hand there are a lot of programmers like me who are also not vocal but think that you are a very positive and influential figure and Clojure is worth learning and using so here it is. Keep up the good work!

    a simple Clojure user

    永久連結embed上層留言檢舉

[–]foobarbazquix 1 指標 2 天前 

On the flip side: In a conversation this week I praised the maintainers of Clojure for their stewardship of the language and what I perceive as exhaustive consideration given to the smallest of changes. I attributed this to part of why the language is so well designed and stable and why I think overall it’s the best language we have been given to date. When I said I sometimes wish the language had a larger community the other person said that would destroy the Clojure I know and love, that the language would be changed to accommodate something like the least common denominator, that it wouldn’t be Clojure anymore. I proudly and with complete confidence said Clojure’s maintainers would never allow that to happen. I recommended Clojure to someone on Twitter who said they liked metaprogramming. I had a positive interaction with a Cognitect employee. I recommended Clojure for in house projects at my company because we are tiny and I find the language confers something like an unfair advantage to those who use it. I worked on a library written in Clojure that can record the operations of functions, simultaneously read the definition of a function from its source and persist all this to another file. I was able to do this fairly easily, and it worked even when the calling code was run from within the file that was being read from. I despaired at the thought of attempting anything like this in any other programming language.

    永久連結embed上層留言檢舉

[+]zcaudate[S] 留言分數低於臨界標準 * (36 下層留言)

[+]downvotes_puffins 留言分數低於臨界標準  (7 下層留言)

[+]visible_gravity 留言分數低於臨界標準  (6 下層留言)

[–]keymone -2 指標 3 天前* 

Thank you for Clojure and continued efforts in making it and ecosystem around it amazing.

Edit: wow, this sub doesn’t react well to puns, noted and removed it.

    永久連結embed上層留言檢舉

[–]zcaudate[S] 1 指標 3 天前 

... it definitely reacts

    永久連結embed上層留言檢舉

[–]Michaelmrose 0 指標 2 天前 

    Every time I have to process such a diatribe and its aftermath, and its effects on myself, my family, and my co-workers, I have to struggle back from "Why should I bother?", and every time it gets harder to justify to myself and my family that it's worth the time, energy and emotional burden. Every time a community engages with such a diatribe without calling it out, and decrying its tone, the civility of our discourse and treatment of others heads further down the drain. It's time for people who value other people to speak out, in this domain and elsewhere:

I honestly don't know why you care. Hate and stupidity are pervasive human qualities. One of the great things about the Internet is the breadth of the perspective it brings. Go looking far enough and you could and whatever your interests, beliefs nationality, race there are probably at least few hundred people who would like to kill you and use you for fertilizer for who you are.

Going to look for idiots on the Internet is bad, engaging them and wasting your energy, feeling bad or angry is worse. You will never enlighten them and the exercise only hurts you and wastes your time which is better spent with work that makes you fulfilled or with your family. Fuck stupid people.
https://www.reddit.com/r/Clojure/comments/73yznc/on_whose_authority/do1olag/

** 23:27 On whose authority?

by Chris Zheng,

...Fuck Clojure.

There I've said it and God it feels good.

I say it with much admiration and respect to all the members of community. I've learnt so much from being in this microcosm of dynamism, ideas and learning over the past 8 years. Clojure has allowed me to get to know so many amazing people, to travel to a whole bunch of places and to do things that I had never thought possible.

Having said that, I've gone from a wide-eyed, idealistic fanboy to someone less idealistic, and almost cynical about the trajectory of the language. I have gained so much - but at the same time, I had expected more. Now I'm just tired.

Like the ending of a long love affair with a girl way out of my league, I loved and loathed every single minute of my time as a clojure developer. The experience, though unforgettable, has taken a toll on my mental and physical well-being. I feel that I have given my all. Now that the party is over and sunrise begins to reveal the plastic fairy lights and overdone makeup, I begin to question my life as well as the values that I am looking for within it.

I remember when I first got into Clojure. I had been struggling to build a concurrent system for years (and to this day, I'm still clueless about how to do it with locks and semaphores). I had been working with python back then and it was really hard work. Then I read Paul Graham's hacker's and painter's book in his article Revenge of the Nerds

"As one data point on the curve, at any rate, if you were to compete with ITA and chose to write your software in C, they would be able to develop software twenty times faster than you. If you spent a year on a new feature, they'd be able to duplicate it in less than three weeks. Whereas if they spent just three months developing something new, it would be five years before you had it too."

My thinking at the time was. Wow. I want to be elite and so after a brief spell with Common Lisp, decided on Clojure. The hook for me (like probably a lot of people) was watching Rich Hickey's epic refutation of OOP and his infamous Ants demo. I was flabbergasted at the fact that I spent 3 months trying to figure out how to get two processes to talk to each other and there was this guy running a graphical simulation of over 100 threads syncing flawlessly. It was a real wake up call to what was possible.

So I dove right in. At the time, no one was employing for Clojure and so I worked as an IT guy in a new age crystal store learning the craft. No one really knew what I was doing and as most of the staff had the innate ability to talk to crystals, they assumed I had the same type of talent except with electronic equiptment. I have very fond memories of the time there both working and learning. I remember that it was around 2010-2013 period where Clojure was really growing in terms of the community and all the interesting ideas that people were implementing. Because of my isolation, I had to resort to asking questions on stackoverflow. I stopped asking a while back but the count of my clojure related questions is currently at 205. Of course, there were a few assholes on SO that find enjoyment marking questions as 'closed' or 'irrelevent' because they didn't understand it correctly. If those questions had been allowed to stay, my SO clojure related count would have been about 230. But who's counting anyways.

There was also the Monthly Melbourne Clojure Meetup Group organised by James and Hank. It was a real treat to talk to those that solved problems through deduction, logic and language instead of massages, eagle feathers and putting crystal on each other.

In the period of 2010 to 2013, so much cool shit came out on a weekly basis. I don't know how it happened. It was a time where I was constantly challenged to improve my thought and design process. The highlights showcased in the 2011 and 2012 conj talks were phenomenal and the level of innovation and experimentation was beyond anything I had experienced. As someone still new to the scene, I was star stuck. 2013 marked the year where clojure 'jumped the shark' so to speak. This marked the path to 'enterprise clojure'. One of the real treats for 2013 was the talk by prismatic where the community was shown that it was not only conceivable, but also possible that an entire platform could be built on clojure. That talk set the bar and the trend of the enterprise platform has continued over the years. Now, it's a staple of a conference to have about half a dozen talks where a team lead (but not necessarily dev) of a well known organisation saying "look everyone, we've built this large data analytics platform using clojure". While it was cool about 5 years ago, I've lost the excitement that those talks once brought.

I've decided to break from actively contributing to the community. This is mainly from actions that I've seen from my perspective that have fragmented community. I'm putting the focus on Cognitect and the company's impact on developer culture.

One. The Establishment and the myth of the Rockstar Developer

I understand that there is great pressure for a company to increase it's product range, market its brand and make money. However, in the case of Cognitect, I feel that the company has had an unreasonable amount of influence of the language. Like a single mother with custody over her kids, Cognitect has definitely been the major force in shaping the direction of development. This is however a double-edged sword. I have had a couple of pull-requests rejected and then introduced a year after I released a library for the feature. I don't think I'm the only person with the experience.

The fact that Cognitect have hired so many high profile contributors to the Clojure ecosystem has resulted in a boost for both the company, as well as the people that work there. Who doesn't want to play guitar and talk immutability with Rich at the watercooler? Rich epitomizes this concept of a 'Rockstar Programmer' - a brilliant, all-round individual who could solve any problem known to man - all in his sleep. I know I believed in it - and the things that I would have given to be part of the 'establishment'

How this mythos influences the community however is subtle, but present. The mythos attracts the gunslingers and the lone rangers of tech. Those that know that anything is possible. For many in the community (including myself to some extent), it also brings out the darker attributes of genius such as narcissim and jealousy. In short, clojure amplifies the qualities inherent within an individual with a tool that is extremely powerful. The need for cooperating with others diminishes and this is not good for community.

Two. Standards and Ignoring the Defacto Community

With great power comes great responsibility. I feel that Cognitect could do a lot more to promote other projects with the clojure ecosystem that are not internal to the company. One example was some of a 'defacto standard' going away was Noir. At it's peak, Noir was a great library for building webapps due to it's emphasis on documentation and design. It had the potential to be something pretty cool if more people supported it. I don't know what happened but suddenly, it was not the flavor of the month anymore. If more collaboration had occured then maybe it would have been different. I don't know. Maybe using compojure was enough. I don't know. I just felt that Noir had the potential to be the 'django of clojure' and due to whatever reason, it never did. Noir was essentially dead in 2013 when Chris Granger started on Light Table and his attention moved else where.

In the last couple of years, two projects gave me doubts as to the intentions of the core. The first was the Arachne project and the second was clojure.spec. I believe that both projects undermined the spirit of generousity by putting the interests of the establishment over that of the whole. Whether deliberate or not, there was a certain set of blinkers put on that ignored alot of what was going on within the broader community.

Since the post was published, there was a a bit of confusion about my portrayal about the status of Arachne. I wanted to clarify that Arachne is not an 'official' Cognitect project. However, there is a certain prestige gained from working at Cognitect and this was what I wanted to express. I personally found the Arachne kickstarter campaign a little bit condescending and I was interested to read yogthos's comment on reddit. I didn't think we needed yet another web framework - we need more documentation, examples and sexy home pages for existing ones. However shallow that may be, it worked for Noir and countless frameworks in other languages. A sexy webpage for Ring would be amazing. I personally would contribute because the library has helped me immensely over the years. I thought that all the campaign was to confuse an already fragmented landscape of web frameworks.

When clojure.spec came out, I was quite sad because I had grown very attached to prismatic/schema. I felt that schema was on the verge of establishing itself as the 'defacto' standard and although spec offered 'additional' features, it meant that the community was forced to choose. The energy and momentum going into schema suddenly stopped and it's a real shame because once the 'official' version comes out, the alternatives tend to be overlooked.

Three. Datomic

Just please open source it already. GraphQL is here to stay and gaining ground. The breakthough technology is somewhat emulated with gundb and very soon the technology could be superceeded.

Quite a few things have happened that made me recently that made me reevaluate how long I should be a developer.

I think I'm still ahead of the curve but I've realised that I can't keep running anymore. Technology pushes forward in leaps and bounds and we the technologists end up getting in the way most of the time. The things we thought impossible has become the norm today. Money, fame, success - they are all so short lived. What's important is community, respect and understanding because it's through others that we grow.

Fuck. Clojure.

Update: I've taken note of some of the confusion with language around the timeline of Noir and the timeline of Arachne and updated the post. Also, the relationship of Arachne and Cognitect can be better explained by Tim Baldridge of Cognitect in the featured comments. 
http://z.caudate.me/on-whose-authority/
## 20171012 -----------------------------------
星期四, 2017/10/12


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

* Event: It finally works

  https://github.com/howardabrams/dot-files/blob/master/emacs-org.org

  From:https://github.com/cosysn/org-gtd/blob/master/org-gtd.el

* Event: yes it works

  

  From:http://www.jvejournals.com/Vibro/article/JVE-16879.html

* Event: 升力面和升力线
升力面方法一般是在环量求解时基于流动无分离假设，当解出叶片攻角后再通过翼型气动数据算出气动力，因此
叶片绕流分离越大时，叶片环量计算偏差越大。
升力线方法在叶片环量计算时就引入翼型气动数据，环量计算更有效。但是，叶片环量方程组是隐式非线性方程组，在
较大偏航角工况等叶片环量分布存在较强的非线性时，方程迭代比较容易发散。
  

  From:《基于自由涡方法的控制过程中风轮气动特性研究》


## 20171013 -----------------------------------
星期五, 2017/10/13


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 15:01 find 

星期五, 2017/10/13




** 15:32 

* Event: org time budget

* How does this differ from Effort estimates?

Effort is an estimate of how long a task will take you to complete. You might get overdue or finish sooner, and that's fine because estimates are guesswork. However, time/clock budget is a fixed quantity you can't go overdue with. A person working 40-hour week has only about 40 hours of free time (5h for 5 work days and 2x10 for weekend), and that's it.

To plan your tasks you use effort estimates, to schedule them within weeks or months you use budget (sometimes called capacity or goal).

For example, you can have a task which might have 30 hour estimate, and you wish to work on it for 3 weeks. Therefore, you'd budget 10 hours weekly to work on this task and no more, allocating the rest of the time to other tasks. If your estimate was too little, you will simply extend the period for another week of 10 hours. If it was too little, you can re-budget the surplus time on other tasks.
Why should I want to budget my time?

Resource allocation is the basis of effectivity. With a purposeful budget you won't get overwhelmed about thinking what to do when. Once you use up all your hours it means you need to work on something else. This way you can spread your work on different tasks to avoid burnout. Coupled with basic scheduling this can lead to surprising amount of "administration" time saved.
When should I budget my time?

A "recommended" work-flow is to have a weekly (or by-weekly) recurring task called "Plan for next week" (fortnight/month...) where you consolidate your tasks and refine your budgets, review stale tasks etc. This can take anywhere from 10 to 60 minutes depending on your level of sophistication. Hitting the sweet-spot of not wasting more time than necessary while freeing you from all the cognitive burden during the week might take some practice and discipline.
  

  From: https://github.com/Fuco1/org-clock-budget

## 20171017 -----------------------------------
星期二, 2017/10/17


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 10:38 clojure dir-fn

{{{
user> (require 'clojure.repl 'clojure.string)
nil
user> (pprint (clojure.repl/dir-fn 'clojure.string))
(blank?
 capitalize
 ends-with?
 escape
 includes?
 index-of
 join
 last-index-of
 lower-case
 re-quote-replacement
 replace
 replace-first
 reverse
 split
 split-lines
 starts-with?
 trim
 trim-newline
 triml
 trimr
 upper-case)
nil
}}}

** 11:09 loop do cucur

user> (loop [i 1] (if (< i  5) (println i) (recur (inc i))))
1
nil
user> (loop [i 1] (if (< i 5) (do (println i) (recur (inc i)))))
1
2
3
4
nil
user> (loop [i 1] (when (< i 5) (println i) (recur (inc i))))
1
2
3
4
nil

** 12:17 clojure典型工作过程



许多 Java 程序员在开始写 Clojure 程序的时候，将写 Java 程序的工作习惯一道带了过来。但是，这两种语言是非常不同的，在 Java 方面工作良好的工作习惯，却不能发挥出 Clojure 的威力。

下文全部用 Cursive IDE 说明。Clojure 高效工作流程的基础，在于：

    REPL。这是威力最强大的武器！我的习惯是一旦打开项目，立即启动 REPL。在 cursive 下，就是按下 cmd+R （第一次运行 REPL 时需要用右键点 project.clj)。

    快捷键，快捷键，快捷键！重要的事说三次。要高效使用 REPL，就不可能把一只手放在鼠标上。在 settings 里搜索 clojure keybinding，使用快捷键。如果你不是疯狂的 Emacs 爱好者，选择 cursive 方案会容易一点。

    随手 Load 代码。写完或改完任何函数后，我会立即按下 Ctrl+C, Ctrl+K 来把程序送进 REPL, 以保证 REPL 里总是最新的版本。

    在文件中写随手测试，并将其送到 REPL，而不是直接在 REPL 中敲键盘！除了正规的测试外，程序中我们会经常尝试些想法，与其每次把这些想法反复敲出来，不如放在源文件中。我一般会在文件结尾放一个 comment，里面放随手尝试代码。只要用cmd+option+x 键就可以把 form 送进 REPL 看结果啦！象这样：

(comment
  (my-function "hello")
  )

    小步写程序。一个函数一个函数写，边写边使用 REPL 试验它们。深思熟虑地一次写一大批代码可能看起来很酷，却往往不是 Clojure 的最佳做法。

https://segmentfault.com/a/1190000004392158

** 12:21 add-remote-javadoc

http://clojure-api-cn.readthedocs.io/en/latest/clojure.java.javadoc/add-remote-javadoc.html
添加路径 url 到远程 javadoc 路径的列表， package-prefix 是 URL 对应的 javadoc 的包名的开始部分。

** 12:39 三个境界(clojure state management)

可以参考《clojure pratical》
其實這個「看山是山，看山不是山，看山仍是山」是禪宗青原行思禪師對自己修行的總結。也是修行人對境緣的三個見地層次：
起初「看山是山」，形容我們在未修行的時候，人家說山我們就一堆妄念，覺得山應該如何如何，要高要翠綠要有這個要有那個等等。打個比方就如在學校學到了很多書本上的知識，覺得這個世界應該是如何如何，尊老愛幼，廉潔正直，做人要有道德等等。一說到某政黨或者國家，大家自然生起一系列聯想。(只是看了）

然後「看山不是山」，就是開始參悟佛理，精進修行，體悟一切的虛幻不實和無常，那裏還來個「山」呢？不過是因緣和合而有之物。繼續用上面的比方，就如當發現一些平常接觸不到的歷史和聽到看到讀到某些平常不讓看的新聞，立馬三觀盡毀，這個世界原來不是我們想像那樣啊！為老不尊，貪污腐敗，少年早熟，一切唯利是圖等等。(看多了，反而乱了)
(观点太多了，似是而非）

最後「看山仍是山」，則是我們徹悟本來，不被虛幻欺騙，可以真真實實地直視世間一切，不再有“應該這樣”、“應該那樣”的聯想。繼續上面的例子：不再執著於“三觀”，任它好壞，世間即是世間，對其喜好厭惡都是我們自己自作多情強加上去的。某國就是某國，貪污也是某國，廉潔也是某國，不再因為對某些元素的喜好厭惡而妄作判斷。能平和無爭，自在無礙地看著，抽離了世俗的眼光而觀。不會再“驚呆了”。(看清楚了，就不乱了)

** 13:53 文献综述

其他作者是怎么描述该作者的工作

该作者做了那个工作，别人是怎么描述的

** 17:26 全球风电2017发展状况

一、过去五年，风电产业取得快速的发展和成长。中国在2012年的时候，风电总装机容量约是6000万千瓦，到2017年已经接近2012年的3倍。而全球的风电产业也取得了重大进展。2012年全球风电总装机容量是2.8亿千瓦，而现在已经超过5亿千瓦，大约是2012的2倍。所以说，风电产业在过去的五年当中取得了很大的成绩。虽然风电市场的增长有它的波动性，不可能总是复制中国2006年3000多万千瓦新增装机容量这样发展的速度，但是如果我们看到最近3年全球新增风电装机容量和3年之前相比，最近3年是之前3年1.4倍。所以说，从全球来看风电产业正在快速成长。

** 17:30 2017年中国风电并网量

http://www.nea.gov.cn/2017-04/25/c_136234299.htm
1-3月，全国风电新增并网容量352万千瓦，截至3月底，累计并网容量达到1.51亿千瓦，累计并网容量同比增长13%；1-3月，全国风电上网电量687亿千瓦时，同比增长26%；平均利用小时数468小时，同比增加46小时；风电弃风电量135亿千瓦时，比去年同期减少57亿千瓦时，弃风限电情况明显好转。

** 23:00 世界主要国家人均能源消费量

http://news.bjx.com.cn/html/20141030/559169.shtml
## 20171019 -----------------------------------
星期四, 2017/10/19


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 11:05 光看文档是学不会的，必须要做一些项目练手、积累经验

定理证明项目从年初写到现在，目前已经积累了 18000 行代码，还差最后一个引理的最后部分就把教授论文里的主定理形式化完成了；HOL 虽然是我自学的，但如果不留这个学我自己永远也学不会，甚至都不知道其存在。
## 20171021 -----------------------------------
星期六, 2017/10/21


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 00:49 align rules

down vote
favorite
10
	

I saw this somewhere, but cannot find it now. Is there a built-in function in emacs, or does someone have elisp, to line up all the equals signs in a series of inititialization statments in cc-mode?

Before:

int t=9;
Graphics g = new Graphics();
List<String> list = new List<String>();

After:

int          t    = 9;
Graphics     g    = new Graphics();
List<String> list = new List<String>();


## 20171022 -----------------------------------
星期日, 2017/10/22


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 15:11 Lisp fantasity

What makes LISP such a fantastic language is that the source code
and data structures are intrinsically one and the same:
the lisp source code you read as a human is almost identical to
how the code is manipulated as a data structure by lisp---the distinction
between the questions "What is data?" and "What is code" are nil

The data as code,the macro system and the ability to "advise" arbitrary
functions--meaning you can modify the behavior of existing code without
copying and modifying the original---give you an unprecedented ability
to alter Emacs to suit your needs.

You can *hook* , replace or alter existing routines in Emacs to suit
your needs without rewriting large swathes of someone else's source 
code.

Emacs is a living systems. When you write elisp, you are not just
writing snippets of code run in a sandbox, isolated from everything
It is a living system; an operationg system running on an operating
system. It is an interpreter

** 15:39 what is buffer in emacs

The buffer is the data structure(this is very important(extremely powerful concept 
because the very same command you use to move around and edit in Emacs
are almost always the same ones you use behind-the-scenes in elisp.

** 15:45 window

Think of it as a physical window having a frame, each 
frame made up of window panes(each window is an window)

why introduce the Point and mark!

keystrokes(key bindings) 

.emacs.d init.el and .eamcs

Major mode and minor mode(key function  highlight --one file extension bind to only one major mode)

** 15:54 font locking

Font locking is the correct term for syntax high-lighting in Emacs, and in turn
is made up of faces of properties(color, font, text size, text style etc) that
the font locking engines use to pretty-point the text.

You are free to change a buffer's major mode at any time by typing the command
for another one.

** 16:03 client-server

Emacs has a client-server architecture(emacs client-server mode)
Emacs --daemon will run emacs as a daemon. It will call server-start,
as above, but will return control to your terminal immediately and run
in background ,waiting for client requests.

** 16:13 M-x

M-x means the execute extended command(M-x) interface and key bindings

So if you're a package author, you have to choose if a particular function 
is accessible to the end-user through the M-x interface(Mx) . Marking 
it as interactive will make it accessible to the end users.

In other words, if it's not interactive ,you cannot run it from M-x nor 
can you bind it to a key

** 16:39 You know what's my talents?

That is what I want? That is why I came here.

** 16:42 Self-documenting editor

Emacs is a sophisticated self-documenting editor. Every facet of
emacs is searchable or describable. Learning how to do this
is absolutely esssential to mastering Emacs.

I use emacs's self-documenting functionality all the time.

Knowing how to get help is critical because
1. emacs knows best .
2. you will find more beautiful and functional features in emacs.

** 16:47 emacs document system

diveded into 3 parts
1. the info manual
2. Apropos(Emacs has an extensive apropos systems that works in much the same 
way as apropos does on the command line.The Apropos system is specially useful
if you 're not entirely sure what you are looking for.(C-h a: M-x apropos-command)
(Hint : Apropos can sort results by relevancy . To enable this
add (setq apropos-sort-by-scores t)
3. the describle system---a living system which describe yourself system.(your

personalize Emacs(M-x describe-mode or C-h m   
C-h f: M-x describe-function
C-h v: M-x describe-variable
C-h k: M-x describe-key

** DONE 16:57 the theory of movement
CLOSED: [2017-10-30 周一 09:07] SCHEDULED: <2017-10-22 周日>

- State "DONE"       from "学习"       [2017-10-30 周一 09:07]
- State "学习"       from              [2017-10-22 周日 17:04]
Getting around, and getting around efficiently, is as important as 
knowing how to edit quickly and efficiently.

But movement in Emacs is more than characters in a buffer.
There's a host of supplementary skills that make up navigation,
like understanding Emacs's rather complicated windowing system.

I've laid things out ,so you can start at the beginning and work
your way through, picking up bits and pieces as you read. The most important
part, as I've stressed many times, is to give it time and practice 
take a moment in your day-to-day life to ask yourself if there's a 
better way of solving with which you are faced

** 17:24 syntax table

syntax table let you choose which is the comment character,
what character make up a word?(symbol. punctuation,comment etc)
as a syntactic unit . So when you move the point around on
the screen, it moves according to the syntax table 
and the general rules governing forward-word and backward-word

Every editor has an equivalent of Emacs's syntax table, but
what sets Emacs apart from other editors is that 
you can inspect and change the syntax table, which in turn will
effect how you invoke certain commands.
## 20171023 -----------------------------------
星期一, 2017/10/23


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 22:31 

** 1  四次剖
    1 大外场关联
    2 一次o剖
    3 机舱前头正方形o剖，然后关联
    4 切割buffer区域 和机舱尾部，关联机舱表面的流向网格线，删除机舱的网格block块
    5.第三次o剖，关联buffer区域的圆，删除buffer内部园，

开始布置网格节点和质量检查
检查差不多，进行第二步散热器的网格划分
2  散热器部分单独选取block快进行o剖
    2.1 注意选取bump上面三个block，
## 20171025 -----------------------------------
星期三, 2017/10/25


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 11:54 Solidworks 重建

ctrl+b 简单重建  刷新
ctrl+q 全部重建（试试他） 在炸不到问题时候，就用它  深层次重建

** 23:48 机械系统

机械系统一般是由若干个物体组成，通过一系列的几何约束连接起来以完成预期动作
的一个整体，因此也可以把整个机械系统叫做多体系统。如果将系统中每个物体都看做
不变性的刚性体，则称该系统为多刚体系统；若系统中有一些物体必须计算其变形，则称之
为多柔体系统或柔性多体系统。多体动力学(MBD)软件的理论基础是多体动力学
## 20171026 -----------------------------------
* 星期四, 2017/10/26

** 22:26 reagent

reagent 是 react 与 cljs 的一个桥接，抽象的比较好，写页面爽多了
不过相比 Clojure，cljs 还是年轻些，工具不是很成熟，但是用没问题
 可能是个小众需求，但是这个过程使用 react + cljs + reagent，也方便回来讲
## 20171027 -----------------------------------
星期五, 2017/10/27


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 12:42 mstsc 远程登陆

首先输入mstsc 然后登陆10.10.10.31(你的电IP是10.10.10.30），注意采用直连的方式进行，
eta机用户名为lzhpc
密码为111111

注意该台电脑是ping不同的，需要在系统设置中 打开允许远程访问的命令

** 15:59 毕业论文长短
我反复提醒自己，毕业论文不在于长短，关键是要言之有物，最起码要在实实在在的工作（代码为证）基础上把所做的内容说清楚，
并且文字要简洁以免给读者造成负担。背景知识可以有但也不必抄书。但除此之外我还可以有别的创新：有时候实现或发现了某个东西是一回事
，正确地解释它则是另一回事。


** 16:31 what on earth emacs  does what you need it

My question is–do you all find that Emacs (and Emacs alone) does what
 you need it to do for your day-to-day work? Or do you find yourselves 
using IDEs regularly, for the fancy features?

100% emacs at all times, for all languages. Even MATLAB!

MATLAB session is in emacs buffer. Can call MATLAB functions, launch plot windows, etc. I usually open another emacs window to edit a .m file in and run it from the shell buffer.

I set it up years ago so I don't remember the details, but there's info online.


**** IDE feature(Add the feature as you want)

That would mean that everyone who use Emacs should implement all ide features. Obviously everyone don’t use every feature, so there is definately situations where it is okay to not have som feature which your coworkers ide has.

** 21:44 let tools to solve problem

Good god, no. The company I work for is pretty deep in Microsoft land, so at a very minimum I need to keep a Windows VM around for Lync and (to some extent) Outlook. Similarly, despite the advances made by Emacs in the area, I doubt I'll be replacing the web browser with Emacs any time soon, web apps (like the Atlassian tools) are way too heavily integrated at my workplace. Code wise I'm happy with Emacs, but then again I don't write Java.

As a professional developer, I think it's important not to get too attached to the tools. They exist to help us solve problems, and when one tool doesn't cut it you pick a different one for the job. 

## 20171028 -----------------------------------
星期六, 2017/10/28


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 16:07 如何拒绝别人

那我建议的拒绝方法是什么呢？你可以这么说：“你看，我今天还有五件事情没有做完，其中一件还是老板今天下午就要的，
我现在着急的很，能不能这样，你先问问别人，如果实在不行，下午快下班那会再说？”

这段话的套路是：

    说事实：“今天有五件事没做完”、“老板今天下午就要”，这些都是事实，当你说出这些事实的时候，对方就知道你为什么要拒绝他，不会产生误解
    谈感受：“我现在着急的很”，当你说出内心感受的时候，对方很容易感同身受、产生共鸣，就不好意思了。
    给建议：“能不能先问问别人……”有了前两层的铺垫，这时候你再说出自己的建议时，对方就容易接受多了。

** 16:34 观点和逻辑线

http://www.gtdlife.com/2017/4807/sheji-yanjianggao/


    观点是一根直线，这是整个演讲的主轴，任何时候都不应该偏离
    逻辑是一条线，这条线是由各种素材组成（也就是“点”）
    情感则是逻辑线上的波峰和波谷，让整条线有了起伏

甜点是为你演讲加分的最后机会

吃甜点的时候，通常是快要结束的时候，大部分人评价一场演讲好不好，通常都是看甜点怎么样，所以有些餐馆虽然主餐一般，但甜点很棒的话，也能拿到高分那甜点怎么让大家觉得很受用呢？

古典老师提到了三种：

    突出得到的东西
    抛出新理念
    吸引人的小故事

## 20171030 -----------------------------------
星期一, 2017/10/30


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 19:52 要做就做的彻底

彻底地把一件事情办好

** 23:16 (source find)

查找find的源码
https://clojuredocs.org/clojure.repl/source
## 20171031 -----------------------------------
星期二, 2017/10/31


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 15:34 clocking only works  with heads                           :clojure:

Clocking only works with headings indented less than 30 stars.
## 20171101 -----------------------------------
* 星期三, 2017/11/1

** 19:26 
## 20171103 -----------------------------------
星期五, 2017/11/3


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 17:02 为什么要使用defmacro?

LISP里的宏之所以被称为宏，是因为它确实包装了很多步骤的操作，两大步：
第一步，像函数那样，宏的body对你传入宏的参数进行操作，进行处理，进行加工；注意，传入宏的参数，是不会被求值的。
第二步，第一步处理的结果，会被LISP-eval，也就是会被LISP执行；而在函数里，整个函数body的执行结果是不会被再次执行的。第二步的再次被执行，这种特性在动态生成代码中是非常OK的，第一步用来生成代码，第二步用来执行这段代码。为什么要动态生成代码呢?

动态变化的过程是data transformation的过程

可以到别的地方去执行，比如
(defmacro make-test(name body)
`(defun ,name ,body)
....)
需要定义测试加法的函数，就可以这样调用 ; (make-test test-+ body)
然后调用test-+

用来创建domain specific language. 换句话来说就是让你的语法更适合问题所在的domain.

Common Lisp的宏特别之处可能就在于能在run time之前多一层macro expansion time。宏扩展的时候可以把代码当作数据来处理，并可以控制宏参数的evalute次数、顺序等。依据这些特性可以用宏生成新的语法规则。写宏的时候要注意variable capture以及form参数的多次evalute.

(defmacro kv [& args]
  `(let [args# (list ~@args)]
     (zipmap (map #(keyword %) '(~@args)) args#)))


(defmacro defn-request [func-name api-key method & args]
  `(defn ~func-name [~@args]
     (url-request-jsonlize
      (request-hof
       ~api-key
       ~method
       (kv ~@args)))))
虽然不是common lisp, 但也是lisp方言(clojure).. 这是我用的比较舒服的宏.. 用参数定义request的发送函数 包括参数表之类的 外围用起来一个很舒服...




** 17:24 defmacro really generate the clojure expression

defmacro will not evaluate the parameter, but the body will evaluate some arguments with ~ and ~@ surround with `

Macro是函数式编程里面很重要的一个概念，在之前，我们已经使用了Clojure里面的一些macro，譬如when，and等，我们可以通过macroexpand获知：

user=> (macroexpand '(when true [1 2 3])))
(if true (do [1 2 3]))
user=> (doc when)
-------------------------
clojure.core/when
([test & body])
Macro
  Evaluates test. If logical true, evaluates body in an implicit do.
nil

可以看到，when其实就是if + do的封装，很类似C语言里面的macro。
defmacro

我们可以通过defmacro来定义macro：

user=> (defmacro my-plus
  #_=> "Another plus for a + b"
  #_=> [args]
  #_=> (list (second args) (first args) (last args)))
#'user/my-plus
user=> (my-plus (1 + 1))
2
user=> (macroexpand '(my-plus (1 + 1)))
(+ 1 1)

macro的定义比较类似函数的定义，我们需要定义一个macro name，譬如上面的my-plus，一个可选择的macro document，一个参数列表以及macro body。body通常会返回一个list用于后续被Clojure进行执行。

我们可以在macro body里面使用任何function，macro以及special form，然后使用macro的时候就跟函数调用一样。但是跟函数不一样的地方在于函数在调用的时候，参数都是先被evaluated，然后才被传入函数里面的，但是对于macro来说，参数是直接传入macro，而没有预先被evaluated。

我们也能在macro里面使用argument destructuring技术，进行参数绑定：

user=> (defmacro my-plus2
  #_=> [[op1 op op2]]
  #_=> (list op op1 op2))
#'user/my-plus2
user=> (my-plus2 (1 + 1))

Symbol and Value

编写macro的时候，我们其实就是构建list供Clojure去evaluate，所以在macro里面，我们需要quote expression，这样才能给Clojure返回一个没有evaluated的list，而不是在macro里面就自己evaluate了。也就是说，我们需要明确了解symbol和value的区别。

譬如，现在我们要实现这样一个功能，一个macro，接受一个expression，打印并且输出它的值，可能看起来像这样:

user=> (let [result 1] (println result) result)
1
1

然后我们定义这个macro：

user=> (defmacro my-print
  #_=> [expression]
  #_=> (list let [result expression]
  #_=> (list println result)
  #_=> result))

我们会发现出错了，错误为"Can't take value of a macro: #'clojure.core/let"，为什么呢？在上面这个例子中，我们其实想得到的是let symbol，而不是得到let这个symbol引用的value，这里let并不能够被evaluate。

所以为了解决这个问题，我们需要quote let，只是返回let这个symbol，然后让Clojure外面去负责evaluate，如下：

user=> (defmacro my-print
  #_=> [expression]
  #_=> (list 'let ['result expression]
  #_=> (list 'println 'result)
  #_=> 'result))
#'user/my-print
user=> (my-print 1)
1
1

Quote
Simple Quoting

如果我们仅仅想得到一个没有evaluated的symbol，我们可以使用quote:

user=> (+ 1 2)
3
user=> (quote (+ 1 2))
(+ 1 2)
user=> '(+ 1 2)
(+ 1 2)
user=> '123
123
user=> 123
123
user=> 'hello
hello
user=> hello

CompilerException java.lang.RuntimeException: Unable to resolve symbol: hello in this context

Syntax Quoting

在前面，我们通过'以及quote了解了simple quoting，Clojure还提供了syntax quoting `

user=> `1
1
user=> `+
clojure.core/+
user=> '+
+

可以看到，syntax quoting会返回fully qualified symbol，所以使用syntax quoting能够让我们避免命名冲突。

另一个syntax quoting跟simple quoting不同的地方在于，我们可以在syntax quoting里面使用~来unquote一些form，这等于是说，我要quote这一个expression，但是这个expression里面某一个form先evaluate，譬如:

user=> `(+ 1 ~(inc 1))
(clojure.core/+ 1 2)
user=> `(+ 1 (inc 1))
(clojure.core/+ 1 (clojure.core/inc 1))

这里还需要注意一下unquote splicing:

user=> `(+ ~(list 1 2 3))
(clojure.core/+ (1 2 3))
user=> `(+ ~@(list 1 2 3))
(clojure.core/+ 1 2 3)

syntax quoting会让代码更加简洁，具体到前面print那个例子，我们let这些都加了quote，代码看起来挺丑陋的，如果用syntax quoting，如下:

user=> (defmacro my-print2
  #_=> [expression]
  #_=> `(let [result# ~expression]
  #_=> (println result#)
  #_=> result#))
#'user/my-print2
user=> (my-print2 1)
1
1



宏存在第二步，这是之前没注意到的，也就是在解释完macro body之后还得解释macro-expansion的内容（这是核心的内容)
让他变着花样地执行！经常会用到的技能是，参数的次序调换。(不求值阶段和求值阶段，两部分，但是说到不求值，也是可以求的
比如~x  ~@(list...)---- 第一阶段code is data, 第二阶段data(list data) is code.

code->data->code->data->code...
eval->apply->eval->apply->eval...


how to uprade your thinking from function to macro?

如果真的是参数比如，红参数中x是5
但是你在宏body肯定使用的是5 如果你使用`(+   4 x) 那么最后就会报错，你得获得x symbol的value，
这时候你就需要使用`(+ 4 ~x) 来执行了，这样你形成的表达式才是(+ 4 5) ,而不是(+ 4 x),他会报错的（在第二阶段中)
也就是宏的第一阶段具备c语言早先的文本替换功能，然后才是clojure升级版的对应地方做执行。
## 20171125 -----------------------------------
星期六, 2017/11/25


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 17:57 CFX也好，Fluent也罢，无所谓强弱。天下还有大大小小的与流体有关软件那么多，比CFX／Fluent口碑好用户广的，还有starCD，NUMECA之类，所以说好坏，不靠谱，也不好评价。
关键在于有限元（FEM）和有限体积（FVM）两种方法算流体，各有优劣。
对应楼主的问题的话，CFX那是基于FEM的，Fluent是基于FVM的。Ansys收购了两家，不是哪个好哪个不好，是为了市场覆盖的需要。
FEM的优点是离散格式丰富，高阶导数的离散精度高，所以对于低速粘性流体和非牛顿流体的求解精度高。再加上有限元擅长做力学，流固边界上的离散精度也高，所以擅长处理流固耦合问题和气动噪声问题。
FVM的优点是离散格式也算丰富而且数学公式比FEM简单的多（看看研究FEM的数学家多少人，而研究FVM的数学家就没几个，从某种意义上说，FVM的数学理论比较没意思，FEM基本继承了有限差分法的发展），守恒性好，这就带来在大多数流体上的计算优势，算得快啊，少占资源啊。FVM最大的缺点，就是算的不准，没办法，少占资源算的快和计算精准本来就是矛盾的两个方面。能兼顾的反正现在还没有。
从工业应用上来说，传统的CFD商软大多采用FVM，少数高端的CFD（功能特别强的，对计算精度要求特别高的，会采用FEM）。举个例子，航空工业，CFX和NUMECA的占用率不知道是Fluent的多少倍，就是因为对计算精度有要求。
这些年，单作流体的人少了，大家还是关心多物理，尤其是流固耦合、气动噪声等等方面，这其实也催生了象COMSOL Multiphysics这样的新生力量，包括Ansys也在提Ansys Multiphysics了。 
