星期六, 2018/2/3


* keep work with jounal (Good for you)
[[https://github.com/howardabrams/dot-files/blob/b2e8a36832d4b9964042aca839f3ff0a3e6724a7/emacs-org.org]]

[[https://github.com/jueqingsizhe66/ranEmacs.d]]

** 09:45 Match with $#-                                               :perl:


#+BEGIN_SRC perl

  $x = "Mmm...donut, thought Homer";
  $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/;    # matches
  print "Match $#- positions\n";

  # foreach $exp (1..$#-) {
  #     print "Match $exp: '${$exp}' at position ($-[$exp],$+[$exp])\n";
  # }
  #

  foreach my $expr ( 1 .. $#- ) {
      printf "Match %s: '%s' at position (%d, %d)\n",
        $expr, substr( $x, $-[$expr], $+[$expr] - $-[$expr] ),   # fixes the error
        $-[$expr], $+[$expr];
  }

  if ( my @matches = $x =~ /^(Mmm|Yech)\.\.\.(donut|peas)/ ) {
      unshift @matches => undef;
      foreach my $expr ( 1 .. $#- ) {
          print
            "Match $expr: '$matches[$expr]' at position ($-[$expr],$+[$expr])\n";
      }
  }

  ""
#+END_SRC



** 09:52 Perl [] and {} , important {}                                :perl:

标量rerence的运用

#+BEGIN_SRC perl
  my $x;
  my $exp;
  for ( my $i = 0 ; $i < 10 ; $i++ ) {
      print "\$$i = $i\n";
  }

  for my $i ( 1 .. 10 ) {
      print "$i\n";
  }

  my $aref = [
      [ "fred",   "barney", "pebbles", "bambam", "dino", ],
      [ "homer",  "bart",   "marge",   "maggie", ],
      [ "george", "jane",   "elroy",   "judy", ],
  ];

  print $aref->[2]->[2], "\n";
  print $aref->[2][2], "\n";


  $aref = [3,4,5,6]; ## autovivification
  @arr = (1,2,3,4);
  $aref=\@arr;
  $aref = [@arr]

  $href= { 1=> 'one'
               2=>'two'}; ### autovivification
  @array = @{$aref}
  %hash =  %{$href}
  @keys  =  keys %{$href};

  Instead of ${$aref}[0] -----> $aref->[0]
             ${$href}{$key} --> $href0>{$key}
#+END_SRC


** 09:59 perl statistics                                              :perl:


#+BEGIN_SRC perl
  use strict;
  use warnings;
  use utf8;
  use Data::Dumper;

  my	$STATI_file_name = 'statistic.dat';		# input file name

  my	%total_bytes;
  open  my $STATI, '<', $STATI_file_name
      or die  "$0 : failed to open  input file '$STATI_file_name' : $!\n";


  while ( <$STATI> ) {

      my  ($source,$destination,$bytes)   = split;##按照空格划分
      $total_bytes{$source}{$destination}+=$bytes;## 累加
  }

  print Dumper(\%total_bytes),"\n";



  foreach my $source ( sort keys %total_bytes ) {

      foreach my $destination (sort keys %{$total_bytes{$source}} ) {
          print "$source => $destination:", "$total_bytes{$source}{$destination} bytes \n";
      }
  }
  close  $STATI
      or warn "$0 : failed to close input file '$STATI_file_name' : $!\n";


#+END_SRC


statistics.dat------------------------->


#+BEGIN_SRC org
  professor.hut gilligan.crew.hut 1250
  professor.hut lovey.howell.hut 910
  thurston.howell.hut lovey.howell.hut 1250
  professor.hut lovey.howell.hut 450
  professor.hut laser3.copyroom.hut 2924
  ginger.girl.hut professor.hut 1218
  ginger.girl.hut maryann.girl.hut 199

#+END_SRC


** 10:02 perl sort                                                    :perl:


#+BEGIN_SRC perl

  ##alphabetically
  my @nums = sort qw/1 2 11 22 10 100/;
  print "Empty: @nums\n";

  my @nums2 = sort { $b cmp $a } qw/1 2 11 22 10 100/;
  print "CMP: @nums2\n";

  my @nums3 = sort { $a cmp $b } qw/1 2 11 22 10 100/;
  print "CMP: @nums3\n";

  ## numerically
  my @nums1 = sort { $a <=> $b } qw/1 2 11 22 10 100/;
  print "Numerically: @nums1\n";

  ## numerically2

  my @num2 = sort compare qw/1 2 11 22 10 100/;
  print "Subroutine: @num2\n";

  sub compare {
      if ( $a < $b ) {
          return -1;
      }
      elsif ( $a == $b ) {
          return 0;
      }
      else {
          return 1;
      }

  }

  ## objectically

#+END_SRC


** 10:04 access people with perl(first cols, then get data from files) :perl:


#+BEGIN_SRC perl
  use strict;
  use warnings;
  use utf8;

  my @records;
  my @cols = ( 's_name', 'f_name', 'job' ); ##列名

  my $FILE_file_name = 'people.dat';    # output file name

  open my $FILE, '<', $FILE_file_name
    or die "$0 : failed to open  output file '$FILE_file_name' : $!\n";
  while (<$FILE>) {
      chomp;
      my %rec;
      @rec{@cols} = split /,/;## split with comma(csv file format)  hash特殊用法
      push @records, \%rec; ### push into records
  }

  close $FILE
    or warn "$0 : failed to close output file '$FILE_file_name' : $!\n";

  foreach (@records) {
      print "$_->{f_name} ", "$_->{s_name} ", "is a $_->{job}\n";
  }


#+END_SRC



#+BEGIN_SRC people.dat
  Jones, Martha, UNIT
   Harkness,JACK,Torchwood
   Smith,Sarah Jane, Journalist

#+END_SRC

** 10:07 grade statistics                                              :perl:

grade tables:


#+BEGIN_SRC org
  Ben 76
  Clementine 49
  Norm 66
  Chris 25
  Doug 35
  Carol 35
  Ben 12
  Clementine 02
  Norm 65


  Norm 33


  Funny 34

#+END_SRC



#+BEGIN_SRC perl

  use strict;
  use warnings;
  use utf8;

  my  $student;
  my  $grade;

  my	%grades;

  my  $scores   = 0;
  my  $total   = 0;
  my  @gradeOf  ;
  my  $line;
  my  $average;


  my	$GRADES_file_name = 'grade.dat';		# input file name

  open  my $FG, '<', $GRADES_file_name
      or die  "$0 : failed to open  input file '$GRADES_file_name' : $!\n";


  while ( $line = <$FG>) {
      next if $line =~ m/^\s*$/g; ### 空行跳出 不进行parse
      chomp($line); ## delete the return symbol
      ($student, $grade) = split(" ", $line);
      $grades{$student} .= $grade . " ";
  }


  foreach my $line ( sort keys %grades ) {
      print "$line => $grades{$line}\n";
  }

  foreach my $student1 ( sort keys %grades  ) {
      my  $scores   = 0;
      my  $total   = 0;
      my  @gradeOf   = split(" ",$grades{$student1});


      foreach my $grade ( @gradeOf ) {
            $total +=$grade;
            $scores++;
      }
      $average = $total / $scores;
      print "$student1: $grades{$student1} \t Average: $average\n";
  }

  close  $FG
      or warn "$0 : failed to close input file '$GRADES_file_name' : $!\n";

#+END_SRC



** 11:17 git stash                                                     :git:



#+BEGIN_SRC sh
  git stash
        git stash save newStashName  也可以取个名字

  git stash list

  git stash apply  从栈顶弹出，（堆栈中依然存在）

  git stash pop  从堆栈中弹出stash（堆栈中不存在了）


  git stash clear  删除所有

  git stash drop stashname  删除制定的stash
#+END_SRC

** 11:27 网站动静分离 (风力机模拟动静分离）                   :EnglishPaper:

静态模拟

动态模拟（动态是指运动的动态特性）

** 11:29 网站四个问题

1. 大访问量
   1. 负载均衡(分流,让每个服务器负载更低，更均衡）
      1. Cisco以太网通道
      2. Windows NLB技术
      3. Linux LVS技术
      4. F5等负载均衡器
   2. 冗余技术(两种技术独立存在）（数据到达某台服务器，服务器突然断电，宕机，于是需要另外一台服务器（备份机位客户提供服务器）
      冗余的目的是防止单点宕机，让客户感觉不到服务器出现问题
2. 大数据量
3. 网站加速(CDN加速）
4. 服务器监控)

** 12:22 rancher完整容器管理平台                                    :Docker:

https://github.com/rancher/rancher

** 13:09 perl分级重组数据                                             :perl:

原始数据

#+BEGIN_SRC org
  风力机
      PhaseVI
      Tj
      Nrel 5MW
      NK 500
  组件
      机舱
      整流罩
      轮毂
      叶片
          翼型
      偏航轴承
      变桨器
      发电机
      制动机
  语言
      c
      perl
      english
      deustch
      java
      matlab
      python
      scheme
      drracket
      lisp
      ruby
      汉语
  数学
      基础数学
      线性代数
      高等代数
      概率学
      矩阵论
      数值分析
      模糊数学
      属性约简

#+END_SRC




#+BEGIN_SRC perl
  use strict;
  use warnings;
  use utf8;
  use Data::Dumper;

  #binmode(STDIN,":encoding(gb2312)");
  #binmode(STDOUT,":encoding(gb2312)");

  binmode(STDIN,":encoding(gbk)");
  binmode(STDOUT,":encoding(gbk)");


  my %provisions;
  my  $person;


  #my	$FEIJI_file_name = 'feiji.txt';		# input file name
  my	$FEIJI_file_name = 'skewdata.txt';		# input file name
  #my	$FEIJI_file_name = 'skewEnglish.txt';		# input file name

  open  my $FEIJI, '<', $FEIJI_file_name
      or die  "$0 : failed to open  input file '$FEIJI_file_name' : $!\n";

  binmode($FEIJI,":encoding(gb2312)");

  while ( <$FEIJI> ) {
  #while ( <> ) {
      # print "Big: $_" if /^(\S.*)/;
      # print "Small $1\n" if /^\s+(\S.*)/;


      if ( /^(\S.*)/ ) {
          $person=$1;
      }
      elsif (/\G(^\s{4}(\S.*))/xgcm) {
          die 'No Person yet!' unless defined $person;
          push @{$provisions{$person}},$1;
      }
      elsif ( /\G(^\s{8}(\S.*))/xgcm ) {
          print "Ok : $1\n";
      }
      else {
          die  "I don't understand: $_";
      }
      #
      # if ( /^(\S.*)/ ) { ## big classification
      #     $person = $1;
      #     print "\$person = $person\n";
      #     ## autovivify
      #     ##$provsions{$person} = []  unless $provsions{$person}; ## did not exist ,so create it
      # }
      # elsif ( /^\s+(\S.*) /) {
      #     die 'No person yet!' unless defined $person;
      #     push @{$provisions{$person}}, $1;
      # }
      # else {
      #     die "I don't understand : $_";
      # }
  }

  close  $FEIJI
      or warn "$0 : failed to close input file '$FEIJI_file_name' : $!\n";


  foreach my $item ( keys %provisions ) {
      print "Big :: $item\n";


      foreach my $little ( @{$provisions{$item}}  ) {
           print "Small $little\n";
      }
      # foreach my $little ( @$item ) {
      #     print "Small $little\n";
      # }
  }

  # print Dumper(\%provisions),"\n";

#+END_SRC

** 13:16 perl替换(汽车到风力机)                                       :perl:

原始文件


#+BEGIN_SRC org
  汽车在高速行驶时，根据空气动力学原理，在行驶过程中会遇到空气阻力，围绕汽车重心同时产生纵向、侧向和垂直上升的三个方向的空气动力量，其中纵向为空气阻力。
  为了有效地减少并克服汽车高速行驶时空气阻力的影响，人们设计使用了汽车尾翼，其作用就是使空气对汽车产生第四种作用力，即产生较大的对地面的附着力，它能抵消一部分升力，有效控制汽车上浮，使风阻系数相应减小，使汽车能紧贴在道路地面行驶，从而提高行驶的稳定性能。

  工作原理
  汽车尾翼作用
  汽车尾翼的作用，就是在汽车高速行驶时，使空气阻力形成一个向下的压力，尽量抵消升力，有效控制气流下压力，使风阻系数相应减小，增加汽车的高速行驶稳定性；由于尾翼能降低汽车的空气阻力，因此高速汽车加装尾翼对于节省燃油也有一定的帮助；同时也使汽车的外形更加美观，起到一定的装饰作用。
  汽车尾翼分类
  玻璃钢尾翼：这类尾翼造型多样，有鸭舌状的、机翼状的，也有直板式的．比较好做造型，不过玻璃钢材质比较脆，韧性和刚性都较差，价格比较便宜。
  铝合金尾翼：这类尾翼导流和散热效果不错，而且价格适中，不过重量要比其他材质的尾翼稍重些。
  碳纤维尾翼：碳纤维尾翼刚性和耐久性都非常好．不仅重量轻而且也是最美观的一种尾翼．现在广泛被F1赛车采用不过价格比较昂贵。[1] 

#+END_SRC


打开中文文件，得用encoding一下


#+BEGIN_SRC perl

  use strict;
  use warnings;
  use utf8;

  binmode(STDIN,":encoding(gb2312)");
  binmode(STDOUT,":encoding(gb2312)");



  open(FEIJI,"feiji.txt") or die "can't open the file \n";
  my $car ="尾翼";

  binmode(FEIJI,":encoding(gb2312)");

  my $count=1;
  while( <FEIJI>){


      s/汽车/风力机/g;
      print;
  }

#+END_SRC

** 13:20 perl sqlite                                           :sqlite:perl:


#+BEGIN_SRC perl
  #
  #C:\Users\YeZhao\perl>perl sqliteLink.pl
  #ADO
  #CSV
  #DBM
  #ExampleP
  #File
  #Gofer
  #ODBC
  #Oracle
  #Pg
  #Proxy
  #SQLite
  #Sponge
  #mysql

  use strict;
  use warnings;
  use utf8;

  use DBI;
  my  @drivers   = DBI->available_drivers();
  print join("\n",@drivers);
  print("\n");

  ## 公共参数
  my  $driver="SQLite";
  my  $db_name="generateSqlite.db";
  # sqlite have no username and password
  my  $username="";
  my  $password   = "";

  my  $connection=getConnection($driver,$db_name,$username,$password);

  my  $tableName="NETWORK";


  ## run only once
  #createDatabaseSource($connection,$tableName);

  queryDB($connection,$tableName);
  #updateCPULoadWithOS($connection,$tableName,'CentOS 7',20);
  #deleteWithID($connection,$tableName,2);
  closeConnection($connection);

  ## 创建并获得数据库连接【2个动作】
  sub getConnection{
      my ($driver,$db_name,$username,$password)  = @_;#$@;
      #print "$db_name\n";
      my $dbd="DBI:$driver:dbname=$db_name";
      my $dbh =DBI->connect($dbd, $username, $password);
      return $dbh;
  }

  ## 创建表
  sub createTable{
      my ($connection,$tableName) = @_;
      my $stmt = qq(CREATE TABLE IF NOT EXISTS ).$tableName.qq(
      (ID INTEGER PRIMARY KEY AUTOINCREMENT,
      HOSTNAME TEXT NOT NULL,
      IPADDRESS INT NOT NULL,
      OS CHAR(50),
      CPULOAD REAL););
      my $ret = $connection->do($stmt);
      if($ret <0){
      print STDERR $DBI::errstr;
      }else{
      print STDERR "Table created successfully\n";
  }
  }


  ## insert data
  sub insertIntoTable{
      my ($connection,$tableName,$HOSTNAME,$IPADDRESS,$OS,$CPULOAD)= @_;
      print "$HOSTNAME, $OS, $CPULOAD\n";
      # VALUES ('xmodulo',16843009,'Ubuntu 14.10',0.0) 
      # VALUES ('bert',16843010,'CentOS 7',0.0)) 
      # VALUES ('puppy',16843011,'Ubuntu 14.10',0.0) 
      my $stmt = qq(INSERT INTO ).$tableName.qq( (HOSTNAME, IPADDRESS, OS,CPULOAD) VALUES )."('$HOSTNAME',$IPADDRESS,'$OS',$CPULOAD)";
      my  $ret = $connection->do($stmt) or die $DBI::errstr;
  }


  sub createDatabaseSource{
      my  ($connection,$tableName)   = @_;
      createTable($connection,$tableName);
      insertIntoTable($connection,$tableName,'xmoudulo',16843009,'Ubuntu15.04','0.1');
      insertIntoTable($connection,$tableName,'bert',16843010,'CentOS 7','0.3');
      insertIntoTable($connection,$tableName,'puppy',16843011,'ubuntu 17.04','0.0');

  }

  # 在表中检索行
  sub queryDB{

      my  ($connection,$tableName)   = @_;
      my $stmt = qq(SELECT id, hostname, os, cpuload from ).$tableName.";";
      my $obj = $connection->prepare($stmt);
      my $ret = $obj->execute() or die $DBI::errstr;
      if($ret <0){
          print STDERR $DBI::errstr;
      }
      while(my @row= $obj->fetchrow_array()){
          print"ID: ". $row[0]."\n";
          print"HOSTNAME: ". $row[1]."\n";
          print"OS: ". $row[2]."\n";
          print"CPULOAD: ". $row[3]."\n\n";
      }

  }


  sub queryWithOs{

  }

  ## 更新
  sub updateCPULoadWithOS{
      my  ($connection,$tableName,$OS,$CPULOAD)   = @_;
      my $stmt = "UPDATE $tableName set CPULOAD =".$CPULOAD." where OS='$OS';";
      print "what:$stmt\n";
      #my $ret = $$connection->do($stmt) or die $DBI::errstr;
      my $ret = $connection->do($stmt) or die $DBI::errstr;
      print "what:$ret\n";
      if( $ret <0){
          print STDERR $DBI::errstr;
      }else{
          print STDERR "A total of $ret rows updated\n";
      }
  }

  ## 删除
  sub deleteWithID{

      my ($connection,$tableName,$ID)=@_;
      my $stmt = qq(DELETE from ).$tableName.qq( where ID=).$ID.";";
      my $ret = $connection->do($stmt) or die $DBI::errstr;
      if($ret <0){
          print STDERR $DBI::errstr;
      }else{
          print STDERR "A total of $ret rows deleted\n";
      }
  }

  sub closeConnection{
      my  $connection   = @_;
      $connection->disconnect();
      print STDERR "Exit current database\n";
  }

#+END_SRC


** 13:37 
