* Quick notes

:LOGBOOK:
CLOCK: [2017-10-02 周一 11:09]--[2017-10-02 周一 11:10] =>  0:01
CLOCK: [2017-09-29 周五 11:03]j


CLOCK: [2017-09-28 周四 13:41]--[2017-09-28 周四 13:42] =>  0:01
:END:
** tomato time [#B]                                                  :@F708:
                           Added: [2017-10-02 周一 11:09]
  ● 开心网的偷菜游戏？你是不是老是惦记着收菜的时间？你收的不是菜，是番茄
  ● 奥运会倒计时，高考倒计时？很大很重要的一个番茄
  ● 老板明天要的资料？味道不怎么样的番茄
我想说的是，番茄时间的核心是倒计时所产生的紧迫感。这是中科院心理学专业毕业的老郭（郭军峰）告诉我的，感谢哦。
** cljrefactor call last thread call [#B]                            :@work:
                           Added: [2017-09-30 周六 05:21]
-https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-thread-first-all


** cljr thread first all [#B]                                        :@work:
                           Added: [2017-09-30 周六 05:23]
                           
https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-thread-last-all

Start with:

(map square (filter even? [1 2 3 4 5]))

Put your cursor in front of the s-exp, and call cljr-thread-last-all:

(->> [1 2 3 4 5]
     (filter even?)
     (map square))

** CFD nacell wiwith bump [#B]                                       :@work:
                           Added: [2017-09-29 周五 11:02]
     首先，总算完成了大小网格的嵌套功能。 划分到机舱的过程中基本上比较正常，就是做了几次o剖而已，然后对应关联而已，
只不过在几何的处理上，有一个很小的技巧就是需要把机舱的线往前copy一个buffer长度的距离，这样就能够做到两次o剖，第三次o剖在过渡到
圆上，在两次o剖后，就可以把机舱的内部网格删掉；而在第三次o剖圆的过程，把圆内的网格再删掉； 还有在第一次o剖机舱头部的时候，需要把
机舱上尾部的点进行split block,尾部的点、线进行关联操作，当然机舱的头部也要进行split block，进行线关联。
     完成了上述的过程之后，也就是最后一步达到buffer区域圆的删除，就可以进一步做bump的切割。这一步的切割很有讲究，流线方向上切上两刀
即可（这边需要注意的是，不要切上三刀，只是bump的前后面即可，把他当作一个正方体去对待，防止切多了，不需要进行流线的线关联了，事先在机
舱头的o剖就已经进行了关联）。注意在你每进行切割的时候，都得把质量检查打开，防止出现太糟糕的网格质量。 要注意的是，从bump开始的切割都
是使用visible select block的方式，而不是All, 现在得选择bump上面的三个block快，然后选择斜边，选择bump竖直方向的第二个点，紧接着切割选择
第三个点，这样就算完成了，然后就是一个关联工作，把bump点关联上，然后是线关联。
      至此完工。 这边有一个对应关系，也就是你需要把梯形体，想成六面体进行切割，正如你在进行o剖的时候，把直翼段想成圆柱段的感觉一样，
然后进行o剖。
** emacs auto open gtd file                                           :NOTE:
                           Added: [2017-09-28 周四 13:40]
  
== Automatically open your todo.org every time you start Emacs ==

Make your life a little bit easier by automatically opening ~/todo.org every time you open Emacs. Add this to the end of your Emacs configuration. To do that,

    C-x C-f ~/.emacs.d/init.el - use find-file to open your configuration file. If it does not yet exist, it is created.
    Go to the end of this file. (Handy shortcut: C-end)
    Add (find-file "~/todo.org")
    Save with C-x C-s (save-buffer).

You can test it with M-x eval-buffer while looking at your ~/.emacs.d/init.el. If it works, it should show you your ~/todo.org file.

You have just written a little Emacs Lisp. Totally not scary.



http://members.optusnet.com.au/~charles57/GTD/datetree.html
 %^g prompts for a tag
I timestamp all my captured items with the line: Added: %U
Some of my items are filed after a specific headline in a file. Appointments are filed under a heading Calendar.
Other entries are filed in date trees. These are explained in the next section


http://blog.csdn.net/u011729865/article/details/54236547


http://blog.csdn.net/jiluben/article/details/39587723
关于org-capture-templates配置代码的解释
原创 2014年09月26日 22:13:02

      对于org-capture-templates的配置，网上只有如下几行代码：

   (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
             "* %?\nEntered on %U\n  %i\n  %a")))
    大家都是这么写，但是并没有解释每个代码的含义。
    经过几次的测试，各个代码的意义大体如下：
    
    现在以

("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")

为例进行说明。
   "t"代表快捷键，如果我们要调用org-capture，必须按下C-c c的组合键，此时emacs就会显示出
一写字母等，如t、j等，这个"t"就是代码中的"t",我们可以根据自己的意愿设置。
   "Todo"目前还不清楚。
    当为"file+headline"时，后面要跟两个参数，一个是文件的地址，如"~/org/gtd.org"，另一个是
我们当前文档所属的标题。本配置中是"Tasks",意味着当我们在按下C-c c t，并输入内容，再按下
C-c C-c后，我们的内容会自动归档到gtd.org文件的Tasks标题下，若文件gtd.org中没有Tasks标题，
系统会自动产生一个。
    "*"具体意义不知道，如果没有，在按下C-c c后，再按t，无法调出gtd文件。
     "TODO"会显示再文本标题中，大家也可以换成"SOMEDAY"等，自己想要的状态。
      "%a"代表你按C-c c前，鼠标所在的内容。
      其它的内容还没有弄明白。

     附：

     %a          annotation, normally the link created with org-store-link
     %i          initial content, the region when capture is called with C-u.
     %t          timestamp, date only
     %T          timestamp with date and time
     %u, %U      like the above, but inactive timestamps
     %?          表示cursor定位于此 开始输入

http://doc.norang.ca/org-mode.html

https://github.com/bbatsov/prelude

https://www.zhihu.com/question/26384934/answer/32686989
大半年前正值我开写博士论文， 对于这种大部头的写作， 提纲无疑十分重要， 我也尝试过许多mindmap软件来做规划， 结果都乱做一团。 最后还是把维度降到1


Org能识别无序列表、有序列表、和描述表


https://link.zhihu.com/?target=http%3A//orgmode.org/org.pdf
** org-bookmark-heading [#B]                                         :@work:
                         Added: [2017-10-14 周六 20:05]
                         
This package provides Emacs bookmark support for org-mode. You can bookmark headings in org-mode files and jump to them using standard Emacs bookmark commands.

It seems like this file should be named org-bookmark.el, but a package by that name already exists in org-mode/contrib which lets org-mode links point to Emacs bookmarks, sort-of the reverse of this package.

It also seems like this should be built-in to org-mode… ;)
** org time budget [#B]                                              :@work:
:LOGBOOK:
CLOCK: [2017-10-14 周六 23:23]--[2017-10-14 周六 23:30] =>  0:07
:END:
                         Added: [2017-10-14 周六 23:23]
** 秀才饿死不买书 [#B]                                               :@F708:
:LOGBOOK:
CLOCK: [2017-10-15 周日 00:29]--[2017-10-15 周日 00:29] =>  0:00
:END:
                         Added: [2017-10-15 周日 00:28]
                        
壮士饿死不迈剑 
** 工作 [#B]                                                         :@work:
:LOGBOOK:
CLOCK: [2017-10-15 周日 01:18]--[2017-10-15 周日 01:24] =>  0:06
:END:
                         Added: [2017-10-15 周日 01:17]
                         
1. 你做了什么
2. 你希望的结果是什么
3. 实际上的结果是什么
https://github.com/marboo/orgmode-cn/blob/master/org.org#Clocking%20work%20time


8.1 时间戳
http://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html#sec-8
跟普通时间戳一样，但是这里是方括号而不是尖括号。这种时间戳是未激活的
，它 不 会让一个条目显示在议程中
** defmulti [#B]                                                     :@work:
:LOGBOOK:
CLOCK: [2017-10-15 周日 13:49]--[2017-10-15 周日 13:49] =>  0:00
:END:
                         Added: [2017-10-15 周日 13:49]

                         http://clojuredocs.org/clojure.core/defmulti
** clojure programming [#B]                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-16 周一 09:16]--[2017-10-16 周一 10:23] =>  1:07
:END:
                         Added: [2017-10-16 周一 09:15]
                         
programming clojure2012.pdf

Chapter7

Macro

With most programming techniques, you build features within language.

when you write macros, it is more accurate to say that you area
"adding features to" the language. This is a powerful and dangerous
ability, so you should follow the rules in 7.1

At least until you have enough experience to decide for yourself when
to bend the rules.

While powerful, macros are not always simple. Clojure works to make macros
as simple as feasible by including convenience to solve many common
problems that occur when writing macros.

taxonomy(分类系统) taxonomy of Macros(7.4 introduces a taxonomy of 
clojure macros, based on the macros in clojure and contrib libraries.

In clojure, you just implement feature X using a macro(while in most
languages, you sense that incompleteness whenever you say,"My life
would be easier if only my language had feature X."

Some expressions, such as
1. numbers
   1. Integers
   2. floats
   3. rationals
2. symbols
3. keywords(numbers,symbols and keywords are self evaluating)
4. Booleans
5. characters
6. functions
7. functions calls
8. macros
9. strings
10. literal maps
11. vectors
12. queues
13. records
14. sets
** PIC [#B]                                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-25 周三 18:32]--[2017-10-25 周三 18:33] =>  0:01
:END:
                         Added: [2017-10-25 周三 18:32]
                         
PIC:记忆时候需要考虑三个组成部分，一purpose二interesting三curiosity也就是你要对你的记忆的目的有一个理性的认识，
进行理性的思考，才能明白其重要性，才能让你持续性工作(理性和专注)，这个过程还得有趣，这样能够保持你的好奇心

当你能跟别人讲的清楚的时候，事先你的记忆也肯定是完全清楚的

好奇心和童心挺像，也就是保持空杯状态

目标写在纸上，量化并且场景化，会让你理性和专注* Quick notes
** emacs highlight [#B]                                              :@F708:
                         Added: [2017-10-09 周一 15:07]
                         作者：BigBoss

(global-hi-lock-mode 1) ;开启全局 hi lock 模式
;避免每次开启 hi lock mode 时询问是否需要高亮指定表达式
(setq hi-lock-file-patterns-policy #'(lambda (dummy) t)) 
; 各种 face 的定义
(defface phone-number-lock-face '((t (:foreground "FF0000"))) t)
(defface language-lock-face '((t (:foreground "00FF00"))) t)
(defface emacs-vim-lock-face '((t (:foreground "9900FF"))) t)

; 利用 highlight-regexp 高亮指定的正则表达式
(defun bigboss-highlight ()
  (interactive)
  (highlight-regexp "0[0-9]\\{2\\}-[0-9]\\{8\\}" 'phone-number-lock-face)
  (highlight-regexp "Lisp\\|Scheme" 'language-lock-face)
  (highlight-regexp "神之编辑器\\|编辑器之神" 'emacs-vim-lock-face)


)

; org mode 中开启高亮
(add-hook 'org-mode-hook 'bigboss-highlight)

https://www.zhihu.com/question/28830039?sort=created
** latex author [#B]                                                 :@work:
                         Added: [2017-10-09 周一 21:41]
                          LaTeX 的作者 Leslie Lamport 

本论文全篇使用Emacs25.3进行文字编辑，Tex Live 2013进行排版设计，git2.13进行版本控制
org——mode进行进度管理。因此要感谢Emacs的发明者Richard Stallman;Tex的发明者Donald Knuth;
git的发明者Linus Torvalds, latex的作者Lesile Lamport;以及Org-mode的发明者carsten Dominik.
** schedule zone [#B]                                                :@work:
                         Added: [2017-10-09 周一 21:44]
                         精确到时间是可以的，时间区间都可以。 格式是：
SCHEDULED: <2015-04-04 Sat 09:00-12:00 ++1d>
这样。上面这句的意思是从4-4日开始， 每天早上的9-12点规划干某件事情。

至于提醒功能， 可以试试org-notify， 不过这个我自己没有用过， 所以不好回答你。
** shift+l [#B]                                                      :@work:
                         Added: [2017-10-09 周一 21:49]
             
你好～想问一下第一张图里面的每个Day下的时间是怎么显示的，
我用C-c C-s 和C-c C-d设置了时间，但是在界面里面却没有显示，我现在用的是emacs25.1。

在 org-agenda 里面按 Shift-l 就可以啦
** add clock summary [#B]                                            :@work:
                         Added: [2017-10-09 周一 22:14]
                         
如何在一个org文件创建clock summary
C-c C-x C-r
** org blog jekyll [#B]                                              :@work:
                         Added: [2017-10-09 周一 22:16]
                         
org-mode可以直接拿来写blog， 这不是什么新鲜事了。  不过最近发现几个项目， 可以方便地从org 输出到jekyll支持的格式。
对于喜欢jekyll，但更喜欢org-mode的同学是个好的解决方案。  当然也有直接从org-mode生成静态网页的。


https://github.com/noinil/prelude/blob/master/personal/noinil.el
https://github.com/noinil/prelude/blob/75d41be0c5da3383cde1bd073c2aa5a9f4b7d792/personal/noinil.el#L397
** emacs 看电影 [#B]                                                 :@F708:
                         Added: [2017-10-09 周一 22:46]
                         用Emacs看电影

大多数人用emacs听歌，我却喜欢用emacs看电影。用 EMMS 和 mplayer 结合，看电影真是太方便了。

不要从源里安装EMMS，它可能给你安装别的播放器，没必要，我们有 mplayer 足够了。从 EMMS 的主页下载，然后编译安装 EMMS 。

然后在 .emacs 中加入如下的配置：
1
2
3
4
5
6
7
8
9
10
11
12
	
(require 'emms-setup)
(emms-standard)
(setq emms-player-list '(emms-player-mplayer) emms-player-mplayer-command-name "mplayer" emms-player-mplayer-parameters '("-slave"))
(setq emms-repeat-playlist nil emms-source-file-default-directory "~/音乐/" emms-lyrics-dir "~/音乐/" emms-lyrics-coding-system nil emms-playlist-buffer-name "*EMMS*")
(global-set-key (kbd "C-c e g") 'emms-play-directory)
(global-set-key (kbd "C-c e d") 'emms-play-dired)
(global-set-key (kbd "C-c e v") 'emms-playlist-mode-go)
(global-set-key (kbd "C-c e x") 'emms-start)
(global-set-key (kbd "C-c e SPC") 'emms-pause)
(global-set-key (kbd "C-c e s") 'emms-stop)
(global-set-key (kbd "C-c e n") 'emms-next)
(global-set-key (kbd "C-c e p") 'emms-previous)

我的emms設置比較簡單，我只是通過它調用mplayer聽歌看電影，不需要看歌詞等額外的功能。我要说的是用 EMMS + mplayer + Dired 可以非常方便地看碟。

通過 Dired 打開電影目錄，比如其中有一個文件夾 辛德勒名單 ，裏面有4 個媒體文件：辛德勒名單CD1.avi、辛德勒名單CD2.avi、辛德勒名單CD3.avi、辛德勒名單CD4.avi。我只需要將光標停在 辛德勒名單 文件夾上，按 C-c e d ，調用 emms-play-dired 函數，則會自動建立播放列表，mplayer 按順序播放這4個文件。

比如有一個電視劇的文件夾 手機 ，裏面共有 36 集，我今天想看 10-12集，用 Dired 進入 手機 文件夾，用 m 在 10-12 集上做標記，然後按 C-c e d ，mplayer 就會順次播放 10-12集。
** emacs多标签 [#B]                                                  :@F708:
                         Added: [2017-10-10 周二 00:41]
                         你的Emacs多标签是用的什么呢？
tabbar-ruler
** win [#B]                                                          :@work:
                         Added: [2017-10-10 周二 01:03]
                         
想在竞赛中获胜， 关键就是要挑自己最在行的项目啊！
所以结论是， 跟他们比笨， 比懒， 比穷。
恭喜你完胜。
** java syscall [#B]                                                 :@F708:
                         Added: [2017-10-10 周二 10:58]
                         
语法糖+syscal
设计的好渐进式发张 即使单进程 照样锤爆
socket 也就是 syscall的问题
和多线程 多进程 协程一样

1:技术是设计的基础，有了技术然后运用技术就能设计出好的产品
2:答：没有设计的产品技术再牛逼也没用，设计才是有技术含量的
技术都是垃圾
** 学习 pattern for life [#B]                                         :NOTE:mm
- State "学习"       from              [2017-10-12 周四 09:55]
                         Added: [2017-10-10 周二 14:00]
                       
在面向对象编程的世界中，我们大量听到"模式"（pattern）这个词，
我觉得那些"模式"就是现实中的因素（c），也就是人肉编译器。
 当我在自己的程序中，发现用到了模式，我觉得这就表明某个地方出错了。
程序的形式，应该仅仅反映它所要解决的问题。代码中其他任何外加的形式，
都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，
也经常提醒我，自己正在手工完成的事情，本应该写代码，通过宏的扩展自动实现。
** blog idea [#B]                                                    :@F708:
                         Added: [2017-10-10 周二 14:02]
                         
当然 blog 还有一个好处就是在把自己的想法表达给大家, 
大家能够听懂的知识才是自己的(有些知识并不是大家都能听懂,有些知识hard to 
understand, hard to use,总是有简单和复杂才能构成真实的世界，都简单的话
那就肯定不真实，这样想也能拓宽你的知识面、认识面)
http://www.woola.net/me
** 产学研 [#B]                                                       :@work:
                         Added: [2017-10-11 周三 11:19]
                         
学校忙着发论文，评职称。私企忙着签合同赚钱。
国企忙着完成资金计划，形象工程。这三者之间有一个共同的利益纽带，是钱。而不是科学。
** RSS Feed [#B]                                                     :@F708:
                         Added: [2017-10-11 周三 22:19]
                         
Use ‘G R’ in the group buffer to create a new group for the feed. When asked, paste the URL to the XML or RDF file 
(I usually paste the URL to the RSS 1.0 feed when given the choice). (You must use G R only when the pointer is not 
on any other group, else it triggers group rename. 
An empty line in the group buffer should work fine.)

The ‘G R’ method does not work for me on gnus 5.10.8, for instance when tried with the url below it says “no such
 newsgroup nnrss:EmacsWiki”. What works for me is hitting ‘G m’ then typing a group name, and specifying nnrss as 
the backend, this creates a group, when entering the group for the first time it prompts for a url.
** fortran+c混编 [#B]                                             :PERSONAL:
:LOGBOOK:
CLOCK: [2017-10-14 周六 22:24]--[2017-10-14 周六 22:25] =>  0:01
:END:
                         Added: [2017-10-12 周四 21:31]
                         
你肯定是没用 ISO_C_binding
现在有了规范的混编方法，一切都简单而优

** logical sequence introduction [#B]                                :@work:
:LOGBOOK:
CLOCK: [2017-10-29 周日 22:06]--[2017-10-29 周日 22:15] =>  0:09
:END:
                         Added: [2017-10-29 周日 22:05]
                         

Before we look at the primary collection types individually, we'll 
discuss the things they have in common. For example, you may have 
heard of clojure's sequence abstraction(都是基于sequence)---all the
persistent collection use it(all :keyword, they :keyword , collective
nouns and abjectives), so we'll examine that as well as some algorithmic
complexity concepts we'll refer to throughout the chapter.


Before....individually ... in common....

is very important. 一方面可以体现出你的逻辑的完整性，另一方面体现你的专业性
同时也可以让你把握重要性，这部分内容只是描述性部分，充当点缀，不是特别核心的地方
相当于引言部分，核心的在不同的地方。

如果你第一次碰到该句话，就可以当作是一个全面性的了解
所以他也是挺重要的
** clojure interop with java [#B]                                    :@work:
:LOGBOOK:
CLOCK: [2017-10-29 周日 22:31]--[2017-10-29 周日 22:31] =>  0:00
:END:
                         Added: [2017-10-29 周日 22:31]
                         

Handling Interop with Java

When a new language comes into being, it faces the library problem. That is, to be useful in everyday situations, 
a language needs to do all the things that current dominant languages do. These current dominant languages have a 
full array of libraries that support things like parsing JSON and logging.

Clojure solved this new language library problem by running on the JVM and having interoperability with Java
 classes. When you use Clojure, you can use Java classes and Java libraries. Clojure builds on the strength 
of the production-hardened and tested JVM and existing Java libraries. In fact, many of the popular Clojure
 libraries in use today utilize Java libraries as fundamental building blocks. We are going to cover the most
 common areas that you will encounter: how to import Java libraries/classes, how to create new instances of 
them, and how to interact with their methods.
** matlab coding style [#B]                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-30 周一 20:57]--[2017-10-30 周一 20:57] =>  0:00
:END:
                         Added: [2017-10-30 周一 20:57]
                         
MATLAB Coding Style

This document suggests a MATLAB coding style. This file is directed to those who code with me in the lab, but might serve for everyone out there.
Coding style

    No whitespace at the end of the line.
    Use Unix style line breaks (LF only).
    Keep line lenghts under 80 characters.
    Use 4 spaces to indent code. Add indentation for each logic level but the function operator:

function a = ackermann(m, n)
% Computes the Ackermann function.
%
if m == 0
    a = n+1;
elseif and(m > 0, n == 0)
    a = ackermann(m-1, 1);
else
    a = ackermann(m-1, ackermann(m, n-1));
end

    For while loops, the counter variable must be declared just before the while keyword:

n = 0;
while n <= 10
    disp(n);
    n = n+10;
end

    If a line is not enough to write the whole statement, break it into meaningful places, like after an operator or separating a line for each function argument:

pyt = sqrt(x^2 + ...
           y^2);
set(handles.edit, ...
    'String', ...
    sprintf('This is worth %.2f$', ...
            pyt));

Keep LISP style indentation in this case for better legibility. Sometimes, it might be a good idea too to break the line before a mathematical operator, to give a more meaningful sense to your code:

result = viscosity ...
       + shear ...
       - (acceleration * mass);

    Name variables and functions using camelCase, as it is Java after all.
    Name constants using UPPERCASE_SEPARATED_BY_UNDERSCORES.
    Always add a space near the equals sign.
    Add spaces after and before brackets in case they define an array or a cell. This space is not needed when accessing data, calling a function or anything like that:

% defining cells or arrays:
emptyCell = { };
someNumbers = [ 1 1 2 3 5 8 13 42 ];

% function call:
someNumbers(5);
someTrouble = ackermann(4, 2);

% accessing data:
emptyCell{end+1} = 19;

    Add spaces between expressions to make them more readable in case they are too long or full of text:

% expressions that needs space for readability:
result = sqrt(x1^2 + y1^2) + sqrt(x2^2 + y2^2) + sqrt(x3^2 + y3^2);
force = mass * acceleration;

% expressions that does not need space for readability:
z = i+1;
f = m*a;

    Your code is mostly like a text, with sentences are paragraphs. Therefore it is a good idea to visually separate concerns within your code with empty lines so new-comers know these concerns. Sometimes, this separations of paragraphs is more useful than documentation itself.

General practices

    Write documentation before writing code. Write documentation before writing code. Write documentation before writing code.
    State your functions' inputs and outputs when documenting it, specially the data types.
    Whenever possible, try to use MATLAB's own math functions. And try to make your own functions comply with their functions. This will make your script a lot more faster and readable.
    Make every function return something unless it is a procedure. 'What does it mean?', you might ask. Ask why for MATLAB and it will answer for you. Actually not. Procedures here can be understand as a series of transformations and steps to achieve a goal, while a function is the transformation itself. A procedure's goal is to cause a side-effect on your system, and this side-effect must be well documented and defined. A function's goal is to create another variable based on other variable's state. This distinction will make your programs less confusing to outsiders, even if they do not know it is there; specially when there are graphical user interfaces (GUIs for short) involved. For example: when you a press a button, it will usually cause a side-effect somewhere, like saving some data to a file or change something else on your GUI. This can be done by performing a procedure, creating and updating variables based on the system's current state. This distinction is subtle but turns everything clearer with practice. Seriously.

Module organization

Regardless of language, we can define a module as a collection of code that tries to solve one problem. This problem can be broad or not, but the idea is to encapsulate this problem into small pieces so the user does not have to think about what is inside. With that in mind, there are some precautions that are considered good taste:

    A MATLAB module is a folder containing functions. So try to keep all your code into one folder. Each file must contain one function that solves one problem inside this bigger problem. If this function needs a helper function, really specific to that domain, then it can be appended to this same file; the outside scripts will not see this helper function. Unless it is desired that it appears somewhere else or it is used repeatedly, this helper should not have a script file for its own.
    Whenever possible, try to solve your problem using only one script file. Most solutions should be considered just another procedure to be included in someone else's code. This is not always the case, since some problems actually need user interfaces and the whatnot, but it can be really nice to just incorporate a single file to the codebase instead of a whole system.

One issue that I have come accross during this time working with this language is that there is considerable namespace pollution given MATLAB does not have any mechanisms to deal with it. Therefore some care is desired when work with them:

    Unless the given module is always used, do not incorporate it directly to MATLAB. Instead, for each script, run the addpath function with the module path. This will keep the current namespace organized. The same applies to the Java classpath.
    One thing to pay attention is that MATLAB does not add nested modules when a folder is inserted to its path. Therefore it might be a good idea to write a function to add the modules whithin for better incorporation, unless you've got somethign to hide from everyone else.
** 流动分离 [#B]                                                     :@work:
:LOGBOOK:
CLOCK: [2017-11-01 周三 14:22]--[2017-11-01 周三 16:43] =>  2:21
:END:
                         Added: [2017-11-01 周三 14:21]
                         

风力机时常处于变风速的流动中，当来流风速接近或超过设计风速时，在叶片的根部或大部分叶展范围都有可能发生流动分离。发生流动分离后，分离流的湍流强度大大增加，引起气动损失迅速增加。同时，流动分离区导致压力平台，减小了内叶展甚至中叶展位置翼型的升力，增加了翼型的阻力。通过在叶片表面加装涡发生器，可以有效控制流动分离，提高翼型升力，降低翼型阻力，从而提高叶片风能吸收效率。
** 三维旋转效应和流动分离 [#B]                                       :@work:
:LOGBOOK:
CLOCK: [2017-11-01 周三 18:20]--[2017-11-02 周四 00:55] =>  6:35
CLOCK: [2017-11-01 周三 17:17]--[2017-11-01 周三 18:19] =>  1:02
:END:
                         Added: [2017-11-01 周三 17:17]
                         
[风力机叶片表面压力的计算与外场测试分析][李仁年] 外场试验表明，叶片表面压力分布
特征沿展向出现较大的差异性，主要原因是在外场多变环境下，高速旋转的风力机叶片存在
较强的三维旋转效应，且三维旋转效应越靠近叶片根部越明显。

当风速超过额定风速后，沿叶展方向的翼型截面会发生动态失速现象，尾涡的形成
和脱落涡将对叶片表面压力分布产生较大影响，产生剧烈的压力波动，致使叶片表面
压力与计算值出现较大差异
** whatis habits [#B]                                                :@work:
:LOGBOOK:
CLOCK: [2017-11-02 周四 20:59]--[2017-11-02 周四 21:00] =>  0:01
:END:
                         Added: [2017-11-02 周四 20:59]
                         
5.3.3 Tracking your habits

Org has the ability to track the consistency of a special category of TODOs, called “habits”. A habit has the following properties:

    You have enabled the habits module by customizing org-modules.
    The habit is a TODO item, with a TODO keyword representing an open state.
    The property STYLE is set to the value habit.
    The TODO has a scheduled date, usually with a .+ style repeat interval. A ++ style may be appropriate for habits with time constraints, e.g., must be done on weekends, or a + style for an unusual habit that can have a backlog, e.g., weekly reports.
    The TODO may also have minimum and maximum ranges specified by using the syntax ‘.+2d/3d’, which says that you want to do the task at least every three days, but at most every two days.
    You must also have state logging for the DONE state enabled (see Tracking TODO state changes), in order for historical data to be represented in the consistency graph. If it is not enabled it is not an error, but the consistency graphs will be largely meaningless. 

To give you an idea of what the above rules look like in action, here's an actual habit with some history:
{{{
     ** TODO Shave
        SCHEDULED: <2009-10-17 Sat .+2d/4d>
        - State "DONE"       from "TODO"       [2009-10-15 Thu]
        - State "DONE"       from "TODO"       [2009-10-12 Mon]
        - State "DONE"       from "TODO"       [2009-10-10 Sat]
        - State "DONE"       from "TODO"       [2009-10-04 Sun]
        - State "DONE"       from "TODO"       [2009-10-02 Fri]
        - State "DONE"       from "TODO"       [2009-09-29 Tue]
        - State "DONE"       from "TODO"       [2009-09-25 Fri]
        - State "DONE"       from "TODO"       [2009-09-19 Sat]
        - State "DONE"       from "TODO"       [2009-09-16 Wed]
        - State "DONE"       from "TODO"       [2009-09-12 Sat]
        :PROPERTIES:
        :STYLE:    habit
        :LAST_REPEAT: [2009-10-19 Mon 00:36]
        :END:
}}}
What this habit says is: I want to shave at most every 2 days (given by the SCHEDULED date and repeat interval) and
 at least every 4 days. If today is the 15th, then the habit first appears in the agenda on Oct 17, after the minimum 
of 2 days has elapsed, and will appear overdue on Oct 19, after four days have elapsed.

What's really useful about habits is that they are displayed along with a consistency graph, to show how consistent
 you've been at getting that task done in the past. This graph shows every day that the task was done over the past 
three weeks, with colors for each day. The colors used are:

Blue
    If the task wasn't to be done yet on that day.
Green
    If the task could have been done on that day.
Yellow
    If the task was going to be overdue the next day.
Red
    If the task was overdue on that day. 

In addition to coloring each day, the day is also marked with an asterisk if the task was actually done that day,
 and an exclamation mark to show where the current day falls in the graph.

There are several configuration variables that can be used to change the way habits are displayed in the agenda.

org-habit-graph-column
    The buffer column at which the consistency graph should be drawn. This will overwrite any text in that column,
 so it is a good idea to keep your habits' titles brief and to the point.
org-habit-preceding-days
    The amount of history, in days before today, to appear in consistency graphs.
org-habit-following-days
    The number of days after today that will appear in consistency graphs.
org-habit-show-habits-only-for-today
    If non-nil, only show habits in today's agenda view. This is set to true by default. 

Lastly, pressing K in the agenda buffer will cause habits to temporarily be disabled and they won't appear at all. 
Press K again to bring them back. They are also subject to tag filtering, 
if you have habits which should only be done in certain contexts, for example. 
https://www.gnu.org/software/emacs/manual/html_mono/org.html#Tracking-your-habits
** tags important [#B]                                               :@work:
:LOGBOOK:
CLOCK: [2017-11-02 周四 21:04]--[2017-11-02 周四 21:04] =>  0:00
:END:
                         Added: [2017-11-02 周四 21:04]
                         
An excellent way to implement labels and contexts for cross-correlating information is to assign tags to headlines.
 Org mode has extensive support for tags.

Every headline can contain a list of tags; they occur at the end of the headline. Tags are normal words containing 
letters, numbers, ‘_’, and ‘@’. Tags must be preceded and followed by a single colon, e.g., ‘:work:’. Several tags
 can be specified, as in ‘:work:urgent:’. Tags will by default be in bold face with the same color as the headline. 
You may specify special faces for 
specific tags using the option org-tag-faces, in much the same way as you can for TODO keywords (see Faces for TODO keywords). 
** Dynamic Stall [#B]                                               :@NCEPU:
:LOGBOOK:
CLOCK: [2018-07-25 周三 10:50]--[2018-07-25 周三 10:55] =>  0:05
:END:
                         Added: [2018-07-25 周三 10:50]
                         
                         
Yaw misalignment introduces the unsteady load , dynamic stall is very important
 because it causes the larger load than static 
 

Yaw misaligment introduces unsteady blade load(产生位置也有了). The occurentce for dynamic stall
is of particular(采用of形式来表达) in this respect, since it can yield(产生)significantly (极大地)
higher aerodynamic blade forces(又加上了balde） than for static stall(加上for， 然后在static后面
再加上stall)

spanwise and temporal extend of the dyanmic stall region 

进一步参考 [Wind turbine aerodynamic in yaw.pdf P153]
** 校医院取药 [#B]                                                  :@NCEPU:
DEADLINE: <2018-08-01 周三>
:LOGBOOK:
CLOCK: [2018-07-31 周二 16:12]--[2018-07-31 周二 16:13] =>  0:01
:END:
                         Added: [2018-07-31 周二 16:12]
                         
