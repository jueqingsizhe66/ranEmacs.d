Quick notes
:LOGBOOK:
CLOCK: [2017-10-02 周一 11:09]
CLOCK: [2017-09-29 周五 11:03]j


CLOCK: [2017-09-28 周四 13:41]--[2017-09-28 周四 13:42] =>  0:01
:END:
** tomato time [#B]                                                  :@F708:
                           Added: [2017-10-02 周一 11:09]
  ● 开心网的偷菜游戏？你是不是老是惦记着收菜的时间？你收的不是菜，是番茄
  ● 奥运会倒计时，高考倒计时？很大很重要的一个番茄
  ● 老板明天要的资料？味道不怎么样的番茄
我想说的是，番茄时间的核心是倒计时所产生的紧迫感。这是中科院心理学专业毕业的老郭（郭军峰）告诉我的，感谢哦。
** cljrefactor call last thread call [#B]                            :@work:
                           Added: [2017-09-30 周六 05:21]
-https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-thread-first-all


** cljr thread first all [#B]                                        :@work:
                           Added: [2017-09-30 周六 05:23]
                           
https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-thread-last-all

Start with:

(map square (filter even? [1 2 3 4 5]))

Put your cursor in front of the s-exp, and call cljr-thread-last-all:

(->> [1 2 3 4 5]
     (filter even?)
     (map square))

** CFD nacell wiwith bump [#B]                                       :@work:
                           Added: [2017-09-29 周五 11:02]
     首先，总算完成了大小网格的嵌套功能。 划分到机舱的过程中基本上比较正常，就是做了几次o剖而已，然后对应关联而已，
只不过在几何的处理上，有一个很小的技巧就是需要把机舱的线往前copy一个buffer长度的距离，这样就能够做到两次o剖，第三次o剖在过渡到
圆上，在两次o剖后，就可以把机舱的内部网格删掉；而在第三次o剖圆的过程，把圆内的网格再删掉； 还有在第一次o剖机舱头部的时候，需要把
机舱上尾部的点进行split block,尾部的点、线进行关联操作，当然机舱的头部也要进行split block，进行线关联。
     完成了上述的过程之后，也就是最后一步达到buffer区域圆的删除，就可以进一步做bump的切割。这一步的切割很有讲究，流线方向上切上两刀
即可（这边需要注意的是，不要切上三刀，只是bump的前后面即可，把他当作一个正方体去对待，防止切多了，不需要进行流线的线关联了，事先在机
舱头的o剖就已经进行了关联）。注意在你每进行切割的时候，都得把质量检查打开，防止出现太糟糕的网格质量。 要注意的是，从bump开始的切割都
是使用visible select block的方式，而不是All, 现在得选择bump上面的三个block快，然后选择斜边，选择bump竖直方向的第二个点，紧接着切割选择
第三个点，这样就算完成了，然后就是一个关联工作，把bump点关联上，然后是线关联。
      至此完工。 这边有一个对应关系，也就是你需要把梯形体，想成六面体进行切割，正如你在进行o剖的时候，把直翼段想成圆柱段的感觉一样，
然后进行o剖。
** emacs auto open gtd file                                           :NOTE:
                           Added: [2017-09-28 周四 13:40]
  
== Automatically open your todo.org every time you start Emacs ==

Make your life a little bit easier by automatically opening ~/todo.org every time you open Emacs. Add this to the end of your Emacs configuration. To do that,

    C-x C-f ~/.emacs.d/init.el - use find-file to open your configuration file. If it does not yet exist, it is created.
    Go to the end of this file. (Handy shortcut: C-end)
    Add (find-file "~/todo.org")
    Save with C-x C-s (save-buffer).

You can test it with M-x eval-buffer while looking at your ~/.emacs.d/init.el. If it works, it should show you your ~/todo.org file.

You have just written a little Emacs Lisp. Totally not scary.



http://members.optusnet.com.au/~charles57/GTD/datetree.html
 %^g prompts for a tag
I timestamp all my captured items with the line: Added: %U
Some of my items are filed after a specific headline in a file. Appointments are filed under a heading Calendar.
Other entries are filed in date trees. These are explained in the next section


http://blog.csdn.net/u011729865/article/details/54236547


http://blog.csdn.net/jiluben/article/details/39587723
关于org-capture-templates配置代码的解释
原创 2014年09月26日 22:13:02

      对于org-capture-templates的配置，网上只有如下几行代码：

   (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
             "* %?\nEntered on %U\n  %i\n  %a")))
    大家都是这么写，但是并没有解释每个代码的含义。
    经过几次的测试，各个代码的意义大体如下：
    
    现在以

("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")

为例进行说明。
   "t"代表快捷键，如果我们要调用org-capture，必须按下C-c c的组合键，此时emacs就会显示出
一写字母等，如t、j等，这个"t"就是代码中的"t",我们可以根据自己的意愿设置。
   "Todo"目前还不清楚。
    当为"file+headline"时，后面要跟两个参数，一个是文件的地址，如"~/org/gtd.org"，另一个是
我们当前文档所属的标题。本配置中是"Tasks",意味着当我们在按下C-c c t，并输入内容，再按下
C-c C-c后，我们的内容会自动归档到gtd.org文件的Tasks标题下，若文件gtd.org中没有Tasks标题，
系统会自动产生一个。
    "*"具体意义不知道，如果没有，在按下C-c c后，再按t，无法调出gtd文件。
     "TODO"会显示再文本标题中，大家也可以换成"SOMEDAY"等，自己想要的状态。
      "%a"代表你按C-c c前，鼠标所在的内容。
      其它的内容还没有弄明白。

     附：

     %a          annotation, normally the link created with org-store-link
     %i          initial content, the region when capture is called with C-u.
     %t          timestamp, date only
     %T          timestamp with date and time
     %u, %U      like the above, but inactive timestamps
     %?          表示cursor定位于此 开始输入

http://doc.norang.ca/org-mode.html

https://github.com/bbatsov/prelude

https://www.zhihu.com/question/26384934/answer/32686989
大半年前正值我开写博士论文， 对于这种大部头的写作， 提纲无疑十分重要， 我也尝试过许多mindmap软件来做规划， 结果都乱做一团。 最后还是把维度降到1


Org能识别无序列表、有序列表、和描述表


https://link.zhihu.com/?target=http%3A//orgmode.org/org.pdf
                         

* Quick notes
** org-color-theme [#B]                                              :@F708:
                           Added: [2017-10-09 周一 02:16]
                           
Org Color Themes
Table of Contents

{Back to Worg's index}
Org Colour Themes

A popular way of customizing Emacs colours is to use the color-theme package (see color-theme emacswiki page.)

Here is a list of color themes that are aware of Org: You can see screen shots of these themes here. Once you have installed a theme it is easy to tweak its appearance by editing the theme's lisp file.

Some of these themes are available in Worg in the color-themes directory, whilst others are linked either to the author's site, or to Github.

There is a page with screenshots of each of the themes here .
color-theme-zenburn.el (maintained by Daniel Brockman)
color-theme-colorful-obsolescence.el (Scott Jaderholm)

Links to Scott's themes all point directly to his site.
color-theme-wombat.el (Scott Jaderholm)
color-theme-active.el (Scott Jaderholm)
color-theme-leuven.el (Fabrice Niessen)
color-theme-zenburn.el (Daniel Brockman Adrian C., Bastien Guerry)
color-theme-tangotango.el (Julien Barnier)

Link to Julien's blog post about tangotango. Link to the Github repository.
color-theme-folio.el color-theme-folio.el (David O'Toole)
color-theme-manoj.el (maintained by Memnon)
color-theme-zenash.el (maintained by Yavuz Arkun)

A modified version of zenburn. Link to the Github repository.
color-theme-dark-emacs.el (maintained by Suvayu Ali)

Based on theme made by the emacswiki user, ZWZ. The original theme can be found here. Suvayu has also made some org-mode font modifications outside of the colour theme, which can be obtained here. Suvayu's init.el gives more information on how to use his customizations.

NB: This theme is not maintained anymore, and won't work with the trunk version of Emacs 24.1. Emacs 24.1 removes support for the deprecated 3rd argument form for face-spec-set. This breaks the color-theme package in general; so instead of waiting for it to be fixed, dark-emacs is now available as an Emacs 24 custom theme. The latest version can be found here.
cyberpunk-theme.el (Nick Van Horn)

Cyberpunk color theme for the emacs 24+ built-in color theme support known loosely as deftheme. The theme is mostly a direct port of the overtone/emacs-live theme of the same name (designed originally for the color-theme package). Many mode-specific customizations, particularly with respect to org-mode, have also been added.
Installing Org Colour Themes.

First make sure that you have the Emacs color-theme package installed. Copy the lisp files for the themes into a directory in your Emacs load path.

If you want to be able to easily cycle between different colour schemes, you need something like the following in your .emacs:

(require 'color-theme)
(setq color-theme-is-global t)
(color-theme-initialize)

(load "color-theme-colorful-obsolescence")
(load "color-theme-zenburn")
(load "color-theme-tangotango")
(load "color-theme-railscast")
(load "color-theme-leuven")
(load "color-theme-folio")
(load "color-theme-zenash")
(load "color-theme-manoj")

(setq my-color-themes (list
  'color-theme-tangotango
  'color-theme-colorful-obsolescence 'color-theme-zenburn
  'color-theme-leuven 'color-theme-folio 
  'color-theme-manoj 'color-theme-zenash
  'color-theme-railscast
))

(defun my-theme-set-default () ; Set the first row
      (interactive)
      (setq theme-current my-color-themes)
      (funcall (car theme-current)))
     
    (defun my-describe-theme () ; Show the current theme
      (interactive)
      (message "%s" (car theme-current)))
     
   ; Set the next theme (fixed by Chris Webber - tanks)
    (defun my-theme-cycle ()            
      (interactive)
      (setq theme-current (cdr theme-current))
      (if (null theme-current)
      (setq theme-current my-color-themes))
      (funcall (car theme-current))
      (message "%S" (car theme-current)))
    
    (setq theme-current my-color-themes)
    (setq color-theme-is-global nil) ; Initialization
    (my-theme-set-default)
    (global-set-key [f4] 'my-theme-cycle)
  

Now you can cycle through the installed themes using the F4 key.

** clojure abbrev [#B]                                               :@F708:
                           Added: [2017-10-09 周一 00:56]
                          ("a"   . "and ")
    ("am"  . "alter-meta! ")
    ("amb" . "alter-meta! ")
    ("ai"  . "assoc-in ")
    ("as"  . "assoc ")
    ("ap"  . "associative? ")
    ("b"   . "binding [$]")
    ("bl"  . "butlast ")
    ("c"   . "count ")
    ("ca"  . ":as ")
    ("ck"  . ":keys [$] ")
    ("co"  . ":or {$}")
    ("con" . ":only [$]")
    ("cp"  . "coll? ")
    ("cr"  . ":refer [$]")
    ("cs"  . ":strs [$]")
    ("cy"  . ":syms [$]")
    ("d"  . "def ")
    ("di"  . "dissoc ")
    ("df"  . "defn $ []\n  ")
    ("dm"  . "defmacro $\n  \"\"\n  []\n  ")
    ("dv"  . "def $ nil\n  \"\"")
    ("ds"  . "doseq [it $]")
    ("dt"  . "deftest ")
    ("ep"  . "empty? ")
    ("f"   . "first ")
    ("fi"  . "filter ")
    ("fp"  . "fn? ")
    ("fn"  . "fn [$]")
    ("g"   . "get ")
    ("gb"  . "group-by ")
    ("gi"  . "get-in ")
    ("i"   . "into ")
    ("ip"  . "instance? ")
    ("idp" . "identical? ")
    ("il"  . "if-let [$]")
    ("kp"  . "keyword? ")
    ("l"   . "let [$]")
    ("let" . "let [$]")
    ("loop" . "loop [$]")
    ("lp"  . "list? ")
    ("m"   . "map ")
    ("mc"  . "mapcat ")
    ("mp"  . "map? ")
    ("n"   . "not ")
    ("np"  . "number? ")
    ("pl"  . "println ")
    ("pn"  . "println ")
    ("r"   . "reduce ")
    ("rb"  . "reset! ")
    ("re"  . "remove ")
    ("rf"  . "re-find #\"$\"")
    ("rs"  . "re-seq #\"$\"")
    ("s"   . "str ")
    ("sb"  . "swap! ")
    ("sk"  . "select-keys ")
    ("sp"  . "seq? ")
    ("stp" . "string? ")
    ("syp" . "symbol? ")
    ("t"   . "throw (Exception. \"$\")")
    ("tt"  . "testing \"$\"")
    ("u"  . "update ")
    ("ui"  . "update-in $ []")
    ("vm"  . "vary-meta ")
    ("vp"  . "vector? ")
    ("w"   . "when ")
    ("wn"  . "when-not ")
    ("wl"  . "when-let [$]")
    ("wb"  . "with-bindings ")
    ("wm"  . "with-meta ")
    ("wo"  . "with-open [$]")
    ("wr"  . "with-redefs [$]")
    ("wis" . "with-in-str ")
    ("wos" . "with-out-str ")
)
** emacs lisp abbrev [#B]                                            :@F708:
                           Added: [2017-10-09 周一 00:49]
                               ("a" . "and ")
    ("ah" . "add-hook '")
    ("atl" . "add-to-list '")
    ("bb" . "bury-buffer")
    ("bc" . "forward-char -1")
    ("bfn" . "buffer-file-name")
    ("bl" . "buffer-list$")
    ("blp" . "buffer-live-p ")
    ("bn" . "buffer-name")
    ("bod" . "beginning-of-defun")
    ("bol" . "forward-line 0$")
    ("bp" . "boundp '")
    ("bs" . "buffer-string$")
    ("bsn" . "buffer-substring-no-properties")
    ("bss" . "buffer-substring ")
    ("bw" . "forward-word -1")
    ("c" . "concat ")
    ("ca" . "char-after$")
    ("cb" . "current-buffer$")
    ("cc" . "condition-case er\n$\n(error nil)")
    ("ci" . "call-interactively ")
    ("cip" . "called-interactively-p 'any")
    ("csv" . "customize-save-variable '")
    ("d" . "delete-char 1")
    ("dc" . "delete-char 1")
    ("dcu" . "defcustom $ t\n  \"\"\n  :type 'boolean")
    ("df" . "defun $ ()\n  \"\"\n  ")
    ("dfa" . "defface $ \n  '((t))\n  \"\"\n  ")
    ("dfc" . "defcustom $ t\n  \"\"\n  :type 'boolean")
    ("dff" . "defface $ \n  '((t))\n  \"\"\n  ")
    ("dfv" . "defvar $ t\n  \"\"")
    ("dk" . "define-key ")
    ("dl" . "dolist (it $)")
    ("dt" . "dotimes (it $)")
    ("dmp" . "derived-mode-p '")
    ("dm" . "defmacro $ ()\n  \"\"\n  ")
    ("dr" . "delete-region ")
    ("dv" . "defvar $ t\n  \"\"")
    ("e" . "error \"$\"")
    ("ef" . "executable-find ")
    ("efn" . "expand-file-name ")
    ("eol" . "end-of-line")
    ("f" . "format \"$\"")
    ("fb" . "fboundp '")
    ("fbp" . "fboundp '")
    ("fc" . "forward-char 1")
    ("ff" . "find-file ")
    ("fl" . "forward-line 1")
    ("fp" . "functionp ")
    ("frp" . "file-readable-p ")
    ("fs" . "forward-sexp 1")
    ("fu" . "funcall ")
    ("fw" . "forward-word 1")
    ("g" . "goto-char ")
    ("gc" . "goto-char ")
    ("gsk" . "global-set-key ")
    ("i" . "insert ")
    ("ie" . "ignore-errors ")
    ("ii" . "interactive")
    ("il" . "if-let (($))")
    ("ir" . "indent-region ")
    ("jcl" . "justify-current-line ")
    ("jl" . "delete-indentation")
    ("jos" . "just-one-space")
    ("jr" . "json-read$")
    ("jtr" . "jump-to-register ")
    ("k" . ("kbd " (format "%S" (key-description (read-key-sequence-vector "Key: ")))))
    ("kb" . "kill-buffer")
    ("kn" . "kill-new ")
    ("kp" . "keywordp ")
    ("l" . "lambda ($)")
    ("la" . ("looking-at \"" - "\""))
    ("lap" . "looking-at-p \"$\"")
    ("lb" . "looking-back \"$\"")
    ("lbp" . "line-beginning-position")
    ("lep" . "line-end-position")
    ("let" . "let (($))")
    ("lp" . "listp ")
    ("m" . "message \"$%s\"")
    ("mb" . "match-beginning 0")
    ("mc" . "mapcar ")
    ("mct" . "mapconcat ")
    ("me" . "match-end 0")
    ("ms" . "match-string 0")
    ("msn" . "match-string-no-properties 0")
    ("msnp" . "match-string-no-properties 0")
    ("msp" . "match-string-no-properties 0")
    ("mt" . "mapconcat ")
    ("n" . "not ")
    ("nai" . "newline-and-indent$")
    ("nl" . "forward-line 1")
    ("np" . "numberp ")
    ("ntr" . "narrow-to-region ")
    ("ow" . "other-window 1")
    ("p" . "point$")
    ("pm" . "point-marker$")
    ("pa" . "point-max$")
    ("pg" . "plist-get ")
    ("pi" . "point-min$")
    ("pz" . "propertize ")
    ("r" . "require '")
    ("ra" . "use-region-p$")
    ("rap" . "use-region-p$")
    ("rb" . "region-beginning")
    ("re" . "region-end")
    ("rh" . "remove-hook '")
    ("rm" . "replace-match \"$\"")
    ("ro" . "regexp-opt ")
    ("rq" . "regexp-quote ")
    ("rris" . "replace-regexp-in-string ")
    ("rrs" . "replace-regexp-in-string ")
    ("rs" . "while (search-forward $ nil t)\n(replace-match \"\") nil t)")
    ("rsb" . "re-search-backward \"$\" nil 'noerror")
    ("rsf" . "re-search-forward \"$\" nil 'noerror")
    ("s" . "setq ")
    ("sb" . "search-backward $ nil 'noerror")
    ("sbr" . "search-backward-regexp $ nil 'noerror")
    ("scb" . "skip-chars-backward \"$\\r\\n[:blank:]\"")
    ("scf" . "skip-chars-forward \"$\\r\\n[:blank:]\"")
    ("se" . "save-excursion")
    ("sf" . "search-forward $ nil 'noerror")
    ("sfr" . "search-forward-regexp $ nil 'noerror")
    ("sic" . "self-insert-command")
    ("sl" . "setq-local ")
    ("sm" . "string-match \"$\"")
    ("smd" . "save-match-data")
    ("sn" . "symbol-name ")
    ("sp" . "stringp ")
    ("sq" . "string= ")
    ("sr" . "save-restriction")
    ("ss" . "substring ")
    ("ssn" . "substring-no-properties ")
    ("ssnp" . "substring-no-properties ")
    ("stb" . "switch-to-buffer ")
    ("sw" . "selected-window$")
    ("syp" . "symbolp ")
    ("tap" . "thing-at-point 'symbol")
    ("tf" . "thread-first ")
    ("tl" . "thread-last ")
    ("u" . "unless ")
    ("ul" . "up-list")
    ("up" . "unwind-protect\n(progn $)")
    ("urp" . "use-region-p$")
    ("w" . "when ")
    ("wcb" . "with-current-buffer ")
    ("wf" . "write-file ")
    ("wh" . "while ")
    ("wl" . "when-let (($))")
    ("we" . "window-end")
    ("ws" . "window-start")
    ("wsw" . "with-selected-window ")
    ("wtb" . "with-temp-buffer")
    ("wtf" . "with-temp-file ")
)
** clojure default snippet [#B]                                      :@work:
                           Added: [2017-10-08 周日 21:37]
                           
Default snippets for Clojure

The snippets that are available in Spacemacs can be found in the yasnippet github repository or in the ~/.emacs.d/elpa/yasnippet-20160501.1841/snippets/clojure-mode directory on your laptop (when yasnippet package is updated then name of that directory will change).

All the current snippets for Clojure mode are in the following table, indicating which tab stops they have.
Snippet 	Description 	Tab Stops
bench 	benchmark an expression, using the time function 	body
bp 	depreciated: break point in swank 	
def 	def expression 	N/A
defm 	defmacro expression, with name, doc-string, arguments & body tabstops 	name, docstring, args, body
defn 	defn expression, with name, doc-string, arguments & body tabstops 	name, docstring, args, body
defr 	defrecord 	docstring, object, args, body
deft 	deftype 	docstring, object, args, body
doseq 	doseq 	name, body
fn 	fn - anonymous function 	name, body
for 	for 	condition, body
if 	if 	condition, body
ifl 	if-let - if true, bind a local name 	binding, body
import 	import java library 	library name
is 	is - clojure test assertion 	value, expected
let 	let - bind a local name to a value 	name, value, body
map 	map 	fn, col, col
map.lambda 	map with anonymous function #() 	fn, body
mdoc 	metadata docstring 	docstring
ns 	ns - expression with the current namespace inserted automatically 	N/A
opts 	destructuring a map with :keys, :or for default values, :as for entire vector 	:key binding, or defaults, :as binding
pr 	prn - print function 	string/value
print 	println - print function 	string/value
reduce 	reduce - reduce expression with an anonymous function 	args, body
require 	:require expression with library and alias 	library, alias
test 	deftest expression 	test description, value/expected
try 	try & catch expression 	try expression, exception name, body
use 	depreciated: use require instead 	
when 	when 	when expression, body
whenl 	when-let - local binding on when condition 	binding, body** design something hard to use [#B]                                 :@F708:
                           Added: [2017-10-07 周六 22:08]
                           
http://www.howardism.org/
22 Feb 2015

After reading the Wired article, Why We Should Design Some Things to Be Difficult to Use, I finally realize that Emacs should be hard to use, and we really should just give up changing it to be easier for new-comers.

This quote sums up my 20 year experience with Emacs:

    [Fujifilm took] the controls out of deep menu functions and putting them back on chrome knobs that just beg to be twiddled.

    I bought a Fujifilm X100 two years ago. It was the first piece of technology I’d bought in 15 years where I had to read the manual. Actually, I’ve read the manual at least four times. Now I’m taking the best pictures of my life, and I love it. By being hard to use, my X100 made me a better photographer.

Seems like Emacs users are now in some elite club where the hazing ritual amounts to learning Lisp. Consequently, I’ve decided to start signing all my Emacs-related correspondence with:

    Yours in Emacs,

    Howard

** data science for making decision [#B]                             :@work:
                           Added: [2017-10-02 周一 21:08]
                           
Data science involves principles（原则）, processes（过程）,
 and techniques（技术  也就是说在后文会介绍这些方面的个中信息） for understanding phenomena via the (automated) analysis of data. For the perspective of this article, the ultimate goal of data science is improving decision making（终极目标提高决策能力）, 
as this generally is of paramount interest to business（对商业来说也是特别重要的）. 
