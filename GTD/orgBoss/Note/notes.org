* Quick notes

:LOGBOOK:
CLOCK: [2017-10-02 周一 11:09]--[2017-10-02 周一 11:10] =>  0:01
CLOCK: [2017-09-29 周五 11:03]j


CLOCK: [2017-09-28 周四 13:41]--[2017-09-28 周四 13:42] =>  0:01
:END:
** tomato time [#B]                                                  :@F708:
                           Added: [2017-10-02 周一 11:09]
  ● 开心网的偷菜游戏？你是不是老是惦记着收菜的时间？你收的不是菜，是番茄
  ● 奥运会倒计时，高考倒计时？很大很重要的一个番茄
  ● 老板明天要的资料？味道不怎么样的番茄
我想说的是，番茄时间的核心是倒计时所产生的紧迫感。这是中科院心理学专业毕业的老郭（郭军峰）告诉我的，感谢哦。
** cljrefactor call last thread call [#B]                            :@work:
                           Added: [2017-09-30 周六 05:21]
-https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-thread-first-all


** cljr thread first all [#B]                                        :@work:
                           Added: [2017-09-30 周六 05:23]
                           
https://github.com/clojure-emacs/clj-refactor.el/wiki/cljr-thread-last-all

Start with:

(map square (filter even? [1 2 3 4 5]))

Put your cursor in front of the s-exp, and call cljr-thread-last-all:

(->> [1 2 3 4 5]
     (filter even?)
     (map square))

** CFD nacell wiwith bump [#B]                                       :@work:
                           Added: [2017-09-29 周五 11:02]
     首先，总算完成了大小网格的嵌套功能。 划分到机舱的过程中基本上比较正常，就是做了几次o剖而已，然后对应关联而已，
只不过在几何的处理上，有一个很小的技巧就是需要把机舱的线往前copy一个buffer长度的距离，这样就能够做到两次o剖，第三次o剖在过渡到
圆上，在两次o剖后，就可以把机舱的内部网格删掉；而在第三次o剖圆的过程，把圆内的网格再删掉； 还有在第一次o剖机舱头部的时候，需要把
机舱上尾部的点进行split block,尾部的点、线进行关联操作，当然机舱的头部也要进行split block，进行线关联。
     完成了上述的过程之后，也就是最后一步达到buffer区域圆的删除，就可以进一步做bump的切割。这一步的切割很有讲究，流线方向上切上两刀
即可（这边需要注意的是，不要切上三刀，只是bump的前后面即可，把他当作一个正方体去对待，防止切多了，不需要进行流线的线关联了，事先在机
舱头的o剖就已经进行了关联）。注意在你每进行切割的时候，都得把质量检查打开，防止出现太糟糕的网格质量。 要注意的是，从bump开始的切割都
是使用visible select block的方式，而不是All, 现在得选择bump上面的三个block快，然后选择斜边，选择bump竖直方向的第二个点，紧接着切割选择
第三个点，这样就算完成了，然后就是一个关联工作，把bump点关联上，然后是线关联。
      至此完工。 这边有一个对应关系，也就是你需要把梯形体，想成六面体进行切割，正如你在进行o剖的时候，把直翼段想成圆柱段的感觉一样，
然后进行o剖。
** emacs auto open gtd file                                           :NOTE:
                           Added: [2017-09-28 周四 13:40]
  
== Automatically open your todo.org every time you start Emacs ==

Make your life a little bit easier by automatically opening ~/todo.org every time you open Emacs. Add this to the end of your Emacs configuration. To do that,

    C-x C-f ~/.emacs.d/init.el - use find-file to open your configuration file. If it does not yet exist, it is created.
    Go to the end of this file. (Handy shortcut: C-end)
    Add (find-file "~/todo.org")
    Save with C-x C-s (save-buffer).

You can test it with M-x eval-buffer while looking at your ~/.emacs.d/init.el. If it works, it should show you your ~/todo.org file.

You have just written a little Emacs Lisp. Totally not scary.



http://members.optusnet.com.au/~charles57/GTD/datetree.html
 %^g prompts for a tag
I timestamp all my captured items with the line: Added: %U
Some of my items are filed after a specific headline in a file. Appointments are filed under a heading Calendar.
Other entries are filed in date trees. These are explained in the next section


http://blog.csdn.net/u011729865/article/details/54236547


http://blog.csdn.net/jiluben/article/details/39587723
关于org-capture-templates配置代码的解释
原创 2014年09月26日 22:13:02

      对于org-capture-templates的配置，网上只有如下几行代码：

   (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")
        ("j" "Journal" entry (file+datetree "~/org/journal.org")
             "* %?\nEntered on %U\n  %i\n  %a")))
    大家都是这么写，但是并没有解释每个代码的含义。
    经过几次的测试，各个代码的意义大体如下：
    
    现在以

("t" "Todo" entry (file+headline "~/org/gtd.org" "Tasks")
             "* TODO %?\n  %i\n  %a")

为例进行说明。
   "t"代表快捷键，如果我们要调用org-capture，必须按下C-c c的组合键，此时emacs就会显示出
一写字母等，如t、j等，这个"t"就是代码中的"t",我们可以根据自己的意愿设置。
   "Todo"目前还不清楚。
    当为"file+headline"时，后面要跟两个参数，一个是文件的地址，如"~/org/gtd.org"，另一个是
我们当前文档所属的标题。本配置中是"Tasks",意味着当我们在按下C-c c t，并输入内容，再按下
C-c C-c后，我们的内容会自动归档到gtd.org文件的Tasks标题下，若文件gtd.org中没有Tasks标题，
系统会自动产生一个。
    "*"具体意义不知道，如果没有，在按下C-c c后，再按t，无法调出gtd文件。
     "TODO"会显示再文本标题中，大家也可以换成"SOMEDAY"等，自己想要的状态。
      "%a"代表你按C-c c前，鼠标所在的内容。
      其它的内容还没有弄明白。

     附：

     %a          annotation, normally the link created with org-store-link
     %i          initial content, the region when capture is called with C-u.
     %t          timestamp, date only
     %T          timestamp with date and time
     %u, %U      like the above, but inactive timestamps
     %?          表示cursor定位于此 开始输入

http://doc.norang.ca/org-mode.html

https://github.com/bbatsov/prelude

https://www.zhihu.com/question/26384934/answer/32686989
大半年前正值我开写博士论文， 对于这种大部头的写作， 提纲无疑十分重要， 我也尝试过许多mindmap软件来做规划， 结果都乱做一团。 最后还是把维度降到1


Org能识别无序列表、有序列表、和描述表


https://link.zhihu.com/?target=http%3A//orgmode.org/org.pdf
** org-bookmark-heading [#B]                                         :@work:
                         Added: [2017-10-14 周六 20:05]
                         
This package provides Emacs bookmark support for org-mode. You can bookmark headings in org-mode files and jump to them using standard Emacs bookmark commands.

It seems like this file should be named org-bookmark.el, but a package by that name already exists in org-mode/contrib which lets org-mode links point to Emacs bookmarks, sort-of the reverse of this package.

It also seems like this should be built-in to org-mode… ;)
** org time budget [#B]                                              :@work:
:LOGBOOK:
CLOCK: [2017-10-14 周六 23:23]--[2017-10-14 周六 23:30] =>  0:07
:END:
                         Added: [2017-10-14 周六 23:23]
** 秀才饿死不买书 [#B]                                               :@F708:
:LOGBOOK:
CLOCK: [2017-10-15 周日 00:29]--[2017-10-15 周日 00:29] =>  0:00
:END:
                         Added: [2017-10-15 周日 00:28]
                        
壮士饿死不迈剑 
** 工作 [#B]                                                         :@work:
:LOGBOOK:
CLOCK: [2017-10-15 周日 01:18]--[2017-10-15 周日 01:24] =>  0:06
:END:
                         Added: [2017-10-15 周日 01:17]
                         
1. 你做了什么
2. 你希望的结果是什么
3. 实际上的结果是什么
https://github.com/marboo/orgmode-cn/blob/master/org.org#Clocking%20work%20time


8.1 时间戳
http://www.cnblogs.com/Open_Source/archive/2011/07/17/2108747.html#sec-8
跟普通时间戳一样，但是这里是方括号而不是尖括号。这种时间戳是未激活的
，它 不 会让一个条目显示在议程中
** defmulti [#B]                                                     :@work:
:LOGBOOK:
CLOCK: [2017-10-15 周日 13:49]--[2017-10-15 周日 13:49] =>  0:00
:END:
                         Added: [2017-10-15 周日 13:49]

                         http://clojuredocs.org/clojure.core/defmulti
** clojure programming [#B]                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-16 周一 09:16]--[2017-10-16 周一 10:23] =>  1:07
:END:
                         Added: [2017-10-16 周一 09:15]
                         
programming clojure2012.pdf

Chapter7

Macro

With most programming techniques, you build features within language.

when you write macros, it is more accurate to say that you area
"adding features to" the language. This is a powerful and dangerous
ability, so you should follow the rules in 7.1

At least until you have enough experience to decide for yourself when
to bend the rules.

While powerful, macros are not always simple. Clojure works to make macros
as simple as feasible by including convenience to solve many common
problems that occur when writing macros.

taxonomy(分类系统) taxonomy of Macros(7.4 introduces a taxonomy of 
clojure macros, based on the macros in clojure and contrib libraries.

In clojure, you just implement feature X using a macro(while in most
languages, you sense that incompleteness whenever you say,"My life
would be easier if only my language had feature X."

Some expressions, such as
1. numbers
   1. Integers
   2. floats
   3. rationals
2. symbols
3. keywords(numbers,symbols and keywords are self evaluating)
4. Booleans
5. characters
6. functions
7. functions calls
8. macros
9. strings
10. literal maps
11. vectors
12. queues
13. records
14. sets
** PIC [#B]                                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-25 周三 18:32]--[2017-10-25 周三 18:33] =>  0:01
:END:
                         Added: [2017-10-25 周三 18:32]
                         
PIC:记忆时候需要考虑三个组成部分，一purpose二interesting三curiosity也就是你要对你的记忆的目的有一个理性的认识，
进行理性的思考，才能明白其重要性，才能让你持续性工作(理性和专注)，这个过程还得有趣，这样能够保持你的好奇心

当你能跟别人讲的清楚的时候，事先你的记忆也肯定是完全清楚的

好奇心和童心挺像，也就是保持空杯状态

目标写在纸上，量化并且场景化，会让你理性和专注* Quick notes
** emacs highlight [#B]                                              :@F708:
                         Added: [2017-10-09 周一 15:07]
                         作者：BigBoss

(global-hi-lock-mode 1) ;开启全局 hi lock 模式
;避免每次开启 hi lock mode 时询问是否需要高亮指定表达式
(setq hi-lock-file-patterns-policy #'(lambda (dummy) t)) 
; 各种 face 的定义
(defface phone-number-lock-face '((t (:foreground "FF0000"))) t)
(defface language-lock-face '((t (:foreground "00FF00"))) t)
(defface emacs-vim-lock-face '((t (:foreground "9900FF"))) t)

; 利用 highlight-regexp 高亮指定的正则表达式
(defun bigboss-highlight ()
  (interactive)
  (highlight-regexp "0[0-9]\\{2\\}-[0-9]\\{8\\}" 'phone-number-lock-face)
  (highlight-regexp "Lisp\\|Scheme" 'language-lock-face)
  (highlight-regexp "神之编辑器\\|编辑器之神" 'emacs-vim-lock-face)


)

; org mode 中开启高亮
(add-hook 'org-mode-hook 'bigboss-highlight)

https://www.zhihu.com/question/28830039?sort=created
** latex author [#B]                                                 :@work:
                         Added: [2017-10-09 周一 21:41]
                          LaTeX 的作者 Leslie Lamport 

本论文全篇使用Emacs25.3进行文字编辑，Tex Live 2013进行排版设计，git2.13进行版本控制
org——mode进行进度管理。因此要感谢Emacs的发明者Richard Stallman;Tex的发明者Donald Knuth;
git的发明者Linus Torvalds, latex的作者Lesile Lamport;以及Org-mode的发明者carsten Dominik.
** schedule zone [#B]                                                :@work:
                         Added: [2017-10-09 周一 21:44]
                         精确到时间是可以的，时间区间都可以。 格式是：
SCHEDULED: <2015-04-04 Sat 09:00-12:00 ++1d>
这样。上面这句的意思是从4-4日开始， 每天早上的9-12点规划干某件事情。

至于提醒功能， 可以试试org-notify， 不过这个我自己没有用过， 所以不好回答你。
** shift+l [#B]                                                      :@work:
                         Added: [2017-10-09 周一 21:49]
             
你好～想问一下第一张图里面的每个Day下的时间是怎么显示的，
我用C-c C-s 和C-c C-d设置了时间，但是在界面里面却没有显示，我现在用的是emacs25.1。

在 org-agenda 里面按 Shift-l 就可以啦
** add clock summary [#B]                                            :@work:
                         Added: [2017-10-09 周一 22:14]
                         
如何在一个org文件创建clock summary
C-c C-x C-r
** org blog jekyll [#B]                                              :@work:
                         Added: [2017-10-09 周一 22:16]
                         
org-mode可以直接拿来写blog， 这不是什么新鲜事了。  不过最近发现几个项目， 可以方便地从org 输出到jekyll支持的格式。
对于喜欢jekyll，但更喜欢org-mode的同学是个好的解决方案。  当然也有直接从org-mode生成静态网页的。


https://github.com/noinil/prelude/blob/master/personal/noinil.el
https://github.com/noinil/prelude/blob/75d41be0c5da3383cde1bd073c2aa5a9f4b7d792/personal/noinil.el#L397
** emacs 看电影 [#B]                                                 :@F708:
                         Added: [2017-10-09 周一 22:46]
                         用Emacs看电影

大多数人用emacs听歌，我却喜欢用emacs看电影。用 EMMS 和 mplayer 结合，看电影真是太方便了。

不要从源里安装EMMS，它可能给你安装别的播放器，没必要，我们有 mplayer 足够了。从 EMMS 的主页下载，然后编译安装 EMMS 。

然后在 .emacs 中加入如下的配置：
1
2
3
4
5
6
7
8
9
10
11
12
	
(require 'emms-setup)
(emms-standard)
(setq emms-player-list '(emms-player-mplayer) emms-player-mplayer-command-name "mplayer" emms-player-mplayer-parameters '("-slave"))
(setq emms-repeat-playlist nil emms-source-file-default-directory "~/音乐/" emms-lyrics-dir "~/音乐/" emms-lyrics-coding-system nil emms-playlist-buffer-name "*EMMS*")
(global-set-key (kbd "C-c e g") 'emms-play-directory)
(global-set-key (kbd "C-c e d") 'emms-play-dired)
(global-set-key (kbd "C-c e v") 'emms-playlist-mode-go)
(global-set-key (kbd "C-c e x") 'emms-start)
(global-set-key (kbd "C-c e SPC") 'emms-pause)
(global-set-key (kbd "C-c e s") 'emms-stop)
(global-set-key (kbd "C-c e n") 'emms-next)
(global-set-key (kbd "C-c e p") 'emms-previous)

我的emms設置比較簡單，我只是通過它調用mplayer聽歌看電影，不需要看歌詞等額外的功能。我要说的是用 EMMS + mplayer + Dired 可以非常方便地看碟。

通過 Dired 打開電影目錄，比如其中有一個文件夾 辛德勒名單 ，裏面有4 個媒體文件：辛德勒名單CD1.avi、辛德勒名單CD2.avi、辛德勒名單CD3.avi、辛德勒名單CD4.avi。我只需要將光標停在 辛德勒名單 文件夾上，按 C-c e d ，調用 emms-play-dired 函數，則會自動建立播放列表，mplayer 按順序播放這4個文件。

比如有一個電視劇的文件夾 手機 ，裏面共有 36 集，我今天想看 10-12集，用 Dired 進入 手機 文件夾，用 m 在 10-12 集上做標記，然後按 C-c e d ，mplayer 就會順次播放 10-12集。
** emacs多标签 [#B]                                                  :@F708:
                         Added: [2017-10-10 周二 00:41]
                         你的Emacs多标签是用的什么呢？
tabbar-ruler
** win [#B]                                                          :@work:
                         Added: [2017-10-10 周二 01:03]
                         
想在竞赛中获胜， 关键就是要挑自己最在行的项目啊！
所以结论是， 跟他们比笨， 比懒， 比穷。
恭喜你完胜。
** java syscall [#B]                                                 :@F708:
                         Added: [2017-10-10 周二 10:58]
                         
语法糖+syscal
设计的好渐进式发张 即使单进程 照样锤爆
socket 也就是 syscall的问题
和多线程 多进程 协程一样

1:技术是设计的基础，有了技术然后运用技术就能设计出好的产品
2:答：没有设计的产品技术再牛逼也没用，设计才是有技术含量的
技术都是垃圾
** 学习 pattern for life [#B]                                         :NOTE:mm
- State "学习"       from              [2017-10-12 周四 09:55]
                         Added: [2017-10-10 周二 14:00]
                       
在面向对象编程的世界中，我们大量听到"模式"（pattern）这个词，
我觉得那些"模式"就是现实中的因素（c），也就是人肉编译器。
 当我在自己的程序中，发现用到了模式，我觉得这就表明某个地方出错了。
程序的形式，应该仅仅反映它所要解决的问题。代码中其他任何外加的形式，
都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，
也经常提醒我，自己正在手工完成的事情，本应该写代码，通过宏的扩展自动实现。
** blog idea [#B]                                                    :@F708:
                         Added: [2017-10-10 周二 14:02]
                         
当然 blog 还有一个好处就是在把自己的想法表达给大家, 
大家能够听懂的知识才是自己的(有些知识并不是大家都能听懂,有些知识hard to 
understand, hard to use,总是有简单和复杂才能构成真实的世界，都简单的话
那就肯定不真实，这样想也能拓宽你的知识面、认识面)
http://www.woola.net/me
** 产学研 [#B]                                                       :@work:
                         Added: [2017-10-11 周三 11:19]
                         
学校忙着发论文，评职称。私企忙着签合同赚钱。
国企忙着完成资金计划，形象工程。这三者之间有一个共同的利益纽带，是钱。而不是科学。
** RSS Feed [#B]                                                     :@F708:
                         Added: [2017-10-11 周三 22:19]
                         
Use ‘G R’ in the group buffer to create a new group for the feed. When asked, paste the URL to the XML or RDF file 
(I usually paste the URL to the RSS 1.0 feed when given the choice). (You must use G R only when the pointer is not 
on any other group, else it triggers group rename. 
An empty line in the group buffer should work fine.)

The ‘G R’ method does not work for me on gnus 5.10.8, for instance when tried with the url below it says “no such
 newsgroup nnrss:EmacsWiki”. What works for me is hitting ‘G m’ then typing a group name, and specifying nnrss as 
the backend, this creates a group, when entering the group for the first time it prompts for a url.
** fortran+c混编 [#B]                                             :PERSONAL:
:LOGBOOK:
CLOCK: [2017-10-14 周六 22:24]--[2017-10-14 周六 22:25] =>  0:01
:END:
                         Added: [2017-10-12 周四 21:31]
                         
你肯定是没用 ISO_C_binding
现在有了规范的混编方法，一切都简单而优

** logical sequence introduction [#B]                                :@work:
:LOGBOOK:
CLOCK: [2017-10-29 周日 22:06]--[2017-10-29 周日 22:15] =>  0:09
:END:
                         Added: [2017-10-29 周日 22:05]
                         

Before we look at the primary collection types individually, we'll 
discuss the things they have in common. For example, you may have 
heard of clojure's sequence abstraction(都是基于sequence)---all the
persistent collection use it(all :keyword, they :keyword , collective
nouns and abjectives), so we'll examine that as well as some algorithmic
complexity concepts we'll refer to throughout the chapter.


Before....individually ... in common....

is very important. 一方面可以体现出你的逻辑的完整性，另一方面体现你的专业性
同时也可以让你把握重要性，这部分内容只是描述性部分，充当点缀，不是特别核心的地方
相当于引言部分，核心的在不同的地方。

如果你第一次碰到该句话，就可以当作是一个全面性的了解
所以他也是挺重要的
** clojure interop with java [#B]                                    :@work:
:LOGBOOK:
CLOCK: [2017-10-29 周日 22:31]--[2017-10-29 周日 22:31] =>  0:00
:END:
                         Added: [2017-10-29 周日 22:31]
                         

Handling Interop with Java

When a new language comes into being, it faces the library problem. That is, to be useful in everyday situations, 
a language needs to do all the things that current dominant languages do. These current dominant languages have a 
full array of libraries that support things like parsing JSON and logging.

Clojure solved this new language library problem by running on the JVM and having interoperability with Java
 classes. When you use Clojure, you can use Java classes and Java libraries. Clojure builds on the strength 
of the production-hardened and tested JVM and existing Java libraries. In fact, many of the popular Clojure
 libraries in use today utilize Java libraries as fundamental building blocks. We are going to cover the most
 common areas that you will encounter: how to import Java libraries/classes, how to create new instances of 
them, and how to interact with their methods.
** matlab coding style [#B]                                          :@F708:
:LOGBOOK:
CLOCK: [2017-10-30 周一 20:57]--[2017-10-30 周一 20:57] =>  0:00
:END:
                         Added: [2017-10-30 周一 20:57]
                         
MATLAB Coding Style

This document suggests a MATLAB coding style. This file is directed to those who code with me in the lab, but might serve for everyone out there.
Coding style

    No whitespace at the end of the line.
    Use Unix style line breaks (LF only).
    Keep line lenghts under 80 characters.
    Use 4 spaces to indent code. Add indentation for each logic level but the function operator:

function a = ackermann(m, n)
% Computes the Ackermann function.
%
if m == 0
    a = n+1;
elseif and(m > 0, n == 0)
    a = ackermann(m-1, 1);
else
    a = ackermann(m-1, ackermann(m, n-1));
end

    For while loops, the counter variable must be declared just before the while keyword:

n = 0;
while n <= 10
    disp(n);
    n = n+10;
end

    If a line is not enough to write the whole statement, break it into meaningful places, like after an operator or separating a line for each function argument:

pyt = sqrt(x^2 + ...
           y^2);
set(handles.edit, ...
    'String', ...
    sprintf('This is worth %.2f$', ...
            pyt));

Keep LISP style indentation in this case for better legibility. Sometimes, it might be a good idea too to break the line before a mathematical operator, to give a more meaningful sense to your code:

result = viscosity ...
       + shear ...
       - (acceleration * mass);

    Name variables and functions using camelCase, as it is Java after all.
    Name constants using UPPERCASE_SEPARATED_BY_UNDERSCORES.
    Always add a space near the equals sign.
    Add spaces after and before brackets in case they define an array or a cell. This space is not needed when accessing data, calling a function or anything like that:

% defining cells or arrays:
emptyCell = { };
someNumbers = [ 1 1 2 3 5 8 13 42 ];

% function call:
someNumbers(5);
someTrouble = ackermann(4, 2);

% accessing data:
emptyCell{end+1} = 19;

    Add spaces between expressions to make them more readable in case they are too long or full of text:

% expressions that needs space for readability:
result = sqrt(x1^2 + y1^2) + sqrt(x2^2 + y2^2) + sqrt(x3^2 + y3^2);
force = mass * acceleration;

% expressions that does not need space for readability:
z = i+1;
f = m*a;

    Your code is mostly like a text, with sentences are paragraphs. Therefore it is a good idea to visually separate concerns within your code with empty lines so new-comers know these concerns. Sometimes, this separations of paragraphs is more useful than documentation itself.

General practices

    Write documentation before writing code. Write documentation before writing code. Write documentation before writing code.
    State your functions' inputs and outputs when documenting it, specially the data types.
    Whenever possible, try to use MATLAB's own math functions. And try to make your own functions comply with their functions. This will make your script a lot more faster and readable.
    Make every function return something unless it is a procedure. 'What does it mean?', you might ask. Ask why for MATLAB and it will answer for you. Actually not. Procedures here can be understand as a series of transformations and steps to achieve a goal, while a function is the transformation itself. A procedure's goal is to cause a side-effect on your system, and this side-effect must be well documented and defined. A function's goal is to create another variable based on other variable's state. This distinction will make your programs less confusing to outsiders, even if they do not know it is there; specially when there are graphical user interfaces (GUIs for short) involved. For example: when you a press a button, it will usually cause a side-effect somewhere, like saving some data to a file or change something else on your GUI. This can be done by performing a procedure, creating and updating variables based on the system's current state. This distinction is subtle but turns everything clearer with practice. Seriously.

Module organization

Regardless of language, we can define a module as a collection of code that tries to solve one problem. This problem can be broad or not, but the idea is to encapsulate this problem into small pieces so the user does not have to think about what is inside. With that in mind, there are some precautions that are considered good taste:

    A MATLAB module is a folder containing functions. So try to keep all your code into one folder. Each file must contain one function that solves one problem inside this bigger problem. If this function needs a helper function, really specific to that domain, then it can be appended to this same file; the outside scripts will not see this helper function. Unless it is desired that it appears somewhere else or it is used repeatedly, this helper should not have a script file for its own.
    Whenever possible, try to solve your problem using only one script file. Most solutions should be considered just another procedure to be included in someone else's code. This is not always the case, since some problems actually need user interfaces and the whatnot, but it can be really nice to just incorporate a single file to the codebase instead of a whole system.

One issue that I have come accross during this time working with this language is that there is considerable namespace pollution given MATLAB does not have any mechanisms to deal with it. Therefore some care is desired when work with them:

    Unless the given module is always used, do not incorporate it directly to MATLAB. Instead, for each script, run the addpath function with the module path. This will keep the current namespace organized. The same applies to the Java classpath.
    One thing to pay attention is that MATLAB does not add nested modules when a folder is inserted to its path. Therefore it might be a good idea to write a function to add the modules whithin for better incorporation, unless you've got somethign to hide from everyone else.
** 流动分离 [#B]                                                     :@work:
:LOGBOOK:
CLOCK: [2017-11-01 周三 14:22]--[2017-11-01 周三 16:43] =>  2:21
:END:
                         Added: [2017-11-01 周三 14:21]
                         

风力机时常处于变风速的流动中，当来流风速接近或超过设计风速时，在叶片的根部或大部分叶展范围都有可能发生流动分离。发生流动分离后，分离流的湍流强度大大增加，引起气动损失迅速增加。同时，流动分离区导致压力平台，减小了内叶展甚至中叶展位置翼型的升力，增加了翼型的阻力。通过在叶片表面加装涡发生器，可以有效控制流动分离，提高翼型升力，降低翼型阻力，从而提高叶片风能吸收效率。
** 三维旋转效应和流动分离 [#B]                                       :@work:
:LOGBOOK:
CLOCK: [2017-11-01 周三 18:20]--[2017-11-02 周四 00:55] =>  6:35
CLOCK: [2017-11-01 周三 17:17]--[2017-11-01 周三 18:19] =>  1:02
:END:
                         Added: [2017-11-01 周三 17:17]
                         
[风力机叶片表面压力的计算与外场测试分析][李仁年] 外场试验表明，叶片表面压力分布
特征沿展向出现较大的差异性，主要原因是在外场多变环境下，高速旋转的风力机叶片存在
较强的三维旋转效应，且三维旋转效应越靠近叶片根部越明显。

当风速超过额定风速后，沿叶展方向的翼型截面会发生动态失速现象，尾涡的形成
和脱落涡将对叶片表面压力分布产生较大影响，产生剧烈的压力波动，致使叶片表面
压力与计算值出现较大差异
** whatis habits [#B]                                                :@work:
:LOGBOOK:
CLOCK: [2017-11-02 周四 20:59]--[2017-11-02 周四 21:00] =>  0:01
:END:
                         Added: [2017-11-02 周四 20:59]
                         
5.3.3 Tracking your habits

Org has the ability to track the consistency of a special category of TODOs, called “habits”. A habit has the following properties:

    You have enabled the habits module by customizing org-modules.
    The habit is a TODO item, with a TODO keyword representing an open state.
    The property STYLE is set to the value habit.
    The TODO has a scheduled date, usually with a .+ style repeat interval. A ++ style may be appropriate for habits with time constraints, e.g., must be done on weekends, or a + style for an unusual habit that can have a backlog, e.g., weekly reports.
    The TODO may also have minimum and maximum ranges specified by using the syntax ‘.+2d/3d’, which says that you want to do the task at least every three days, but at most every two days.
    You must also have state logging for the DONE state enabled (see Tracking TODO state changes), in order for historical data to be represented in the consistency graph. If it is not enabled it is not an error, but the consistency graphs will be largely meaningless. 

To give you an idea of what the above rules look like in action, here's an actual habit with some history:
{{{
     ** TODO Shave
        SCHEDULED: <2009-10-17 Sat .+2d/4d>
        - State "DONE"       from "TODO"       [2009-10-15 Thu]
        - State "DONE"       from "TODO"       [2009-10-12 Mon]
        - State "DONE"       from "TODO"       [2009-10-10 Sat]
        - State "DONE"       from "TODO"       [2009-10-04 Sun]
        - State "DONE"       from "TODO"       [2009-10-02 Fri]
        - State "DONE"       from "TODO"       [2009-09-29 Tue]
        - State "DONE"       from "TODO"       [2009-09-25 Fri]
        - State "DONE"       from "TODO"       [2009-09-19 Sat]
        - State "DONE"       from "TODO"       [2009-09-16 Wed]
        - State "DONE"       from "TODO"       [2009-09-12 Sat]
        :PROPERTIES:
        :STYLE:    habit
        :LAST_REPEAT: [2009-10-19 Mon 00:36]
        :END:
}}}
What this habit says is: I want to shave at most every 2 days (given by the SCHEDULED date and repeat interval) and
 at least every 4 days. If today is the 15th, then the habit first appears in the agenda on Oct 17, after the minimum 
of 2 days has elapsed, and will appear overdue on Oct 19, after four days have elapsed.

What's really useful about habits is that they are displayed along with a consistency graph, to show how consistent
 you've been at getting that task done in the past. This graph shows every day that the task was done over the past 
three weeks, with colors for each day. The colors used are:

Blue
    If the task wasn't to be done yet on that day.
Green
    If the task could have been done on that day.
Yellow
    If the task was going to be overdue the next day.
Red
    If the task was overdue on that day. 

In addition to coloring each day, the day is also marked with an asterisk if the task was actually done that day,
 and an exclamation mark to show where the current day falls in the graph.

There are several configuration variables that can be used to change the way habits are displayed in the agenda.

org-habit-graph-column
    The buffer column at which the consistency graph should be drawn. This will overwrite any text in that column,
 so it is a good idea to keep your habits' titles brief and to the point.
org-habit-preceding-days
    The amount of history, in days before today, to appear in consistency graphs.
org-habit-following-days
    The number of days after today that will appear in consistency graphs.
org-habit-show-habits-only-for-today
    If non-nil, only show habits in today's agenda view. This is set to true by default. 

Lastly, pressing K in the agenda buffer will cause habits to temporarily be disabled and they won't appear at all. 
Press K again to bring them back. They are also subject to tag filtering, 
if you have habits which should only be done in certain contexts, for example. 
https://www.gnu.org/software/emacs/manual/html_mono/org.html#Tracking-your-habits
** tags important [#B]                                               :@work:
:LOGBOOK:
CLOCK: [2017-11-02 周四 21:04]--[2017-11-02 周四 21:04] =>  0:00
:END:
                         Added: [2017-11-02 周四 21:04]
                         
An excellent way to implement labels and contexts for cross-correlating information is to assign tags to headlines.
 Org mode has extensive support for tags.

Every headline can contain a list of tags; they occur at the end of the headline. Tags are normal words containing 
letters, numbers, ‘_’, and ‘@’. Tags must be preceded and followed by a single colon, e.g., ‘:work:’. Several tags
 can be specified, as in ‘:work:urgent:’. Tags will by default be in bold face with the same color as the headline. 
You may specify special faces for 
specific tags using the option org-tag-faces, in much the same way as you can for TODO keywords (see Faces for TODO keywords). 
** Dynamic Stall [#B]                                               :@NCEPU:
:LOGBOOK:
CLOCK: [2018-07-25 周三 10:50]--[2018-07-25 周三 10:55] =>  0:05
:END:
                         Added: [2018-07-25 周三 10:50]
                         
                         
Yaw misalignment introduces the unsteady load , dynamic stall is very important
 because it causes the larger load than static 
 

Yaw misaligment introduces unsteady blade load(产生位置也有了). The occurentce for dynamic stall
is of particular(采用of形式来表达) in this respect, since it can yield(产生)significantly (极大地)
higher aerodynamic blade forces(又加上了balde） than for static stall(加上for， 然后在static后面
再加上stall)

spanwise and temporal extend of the dyanmic stall region 

进一步参考 [Wind turbine aerodynamic in yaw.pdf P153]


记得在cygwin安装tree
#+BEGIN_SRC bash :dir "I:\\ScienceBase.Attachments\\data missing estimation\\"
  find
#+END_SRC


#+BEGIN_SRC bash :dir "I:\\ScienceBase.Attachments\\data missing estimation\\"
  perl hello.pl 
#+END_SRC


#+RESULTS:
** NoteExpress标记 [#B]                                             :@NCEPU:
:LOGBOOK:
CLOCK: [2018-08-04 周六 09:33]--[2018-08-04 周六 09:44] =>  0:11
:END:
                         Added: [2018-08-04 周六 09:32]
                         

标记星级+优先级(刚开始是一级，如果觉得好变成2级，再看一遍觉得特别不错，变成三级..)
** 搜索引擎出现的必然 [#B]                                          :@NCEPU:
:LOGBOOK:
CLOCK: [2018-08-04 周六 09:44]--[2018-08-04 周六 09:45] =>  0:01
:END:
                         Added: [2018-08-04 周六 09:44]
                         
从只言片语到书册，再到图书馆以及搜索引擎
https://www.baidu.com/s?wd=how%20search%20works&rsv_spt=1&rsv_iqid=0x9c499bc9000313b6&issp=1&f=8&rsv_bp=0&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_sug3=17&rsv_sug1=7&rsv_sug7=100&rsv_sug2=0&inputT=4271&rsv_sug4=4272

1. 爬虫抓取信息(following links ,inside links  connected into thousands and millions information web)，按照高质量网站优先原则
2. 进行index
3. 通过算法，better understand what you mean理解你的输入内容，进行搜索 base on the relevent clues, 
4. 不断过滤掉垃圾网页（site & page quality高质量网站显示在前! 

https://www.google.com/intl/bn/insidesearch/howsearchworks/thestory/
Jake Hubert, Google Product Manager, said in a blog, “Here you can follow the entire life of a search query,
 from the web, to crawling and indexing(1), to algorithmic ranking(2) and serving(3), to fighting webspam(去掉垃圾信息).”
 

 
1. keyword
2. rank and sort(整理)
3. qualitiy


级别1： 只会输入单词的
级别2： 关键词组合 基本逻辑关系(and：空格表示 or not)  高级检索(site:  ftp:   filetype:pdf)
句子的话涉及拆词问题(关键词组合，跟浏览器的搜商有关)，  + 强制添加   -减号强制剔除
级别3： 高校检索 黑客级别

各个搜搜引擎差异在于专业性知识收集不同、展示界面不同

乔纳森-弗莱彻：被遗忘的搜索引擎之父
腾讯科技[微博]瑞雪2013年09月05日02:47我要分享
[导读]20年前，弗莱彻发明了全世界第一个能进行网络搜索的搜索引擎。

乔纳森-弗莱彻：被遗忘的搜索引擎之父

弗莱彻（中）与SIGIR大会的其他与会者在一起（腾讯科技配图）

腾讯科技 瑞雪 9月5日编译

在谷歌(微博)庆祝其15周年诞辰之际，这家网络巨头已经成为信息检索的代名词。

但是，如果你在谷歌搜索引擎中输入乔纳森·弗莱彻（Jonathon Fletcher）的名字，那么在马上得出的搜索结果中不会找到什么线索指向他曾在万维网发展的过程中所扮演的角色。当然，也不会有任何信息能表明他作为现代搜索引擎之父的身份。

但在20年以前，正是弗莱彻在苏格兰斯特灵大学（University of Stirling）的一个电脑实验室中发明了全世界第一个能进行网络搜索的搜索引擎，也正是他发明的这种技术为谷歌、必应（Bing）、雅虎和今天网络上的所有大型搜索工具提供了支持。

解决网络搜索问题

在1993年时，网络正处于刚刚开始发展的婴儿期。在那时，第一个拥有类似于今天我们使用的界面的流行浏览器Mosaic刚刚发布，网页的总数量还只是以千为单位来进行计算而已。

尽管当时网络已经诞生，但如何在网络上找到内容的问题尚未得到解决。Mosaic拥有一个名为“What's New”的页面，能在新网站被创立时检索到这些网站。但问题在于，如果想要Mosaic的开发者能够知道一个新网站的诞生，那么其创立者就必须写信给美国伊利诺伊大学香槟分校（University of Illinois Urbana-Champaign）的国家超级计算应用中心（NCSA），也就是Mosaic浏览器团队的基地。

在那时，弗莱彻是斯特灵大学一名颇有前途的研究生，而且已经被推荐到格拉斯哥大学（University of Glasgow）攻读博士学位。但是，格拉斯哥大学的资金链在弗莱彻还没能到这所大学以前就已断裂，这让他变得无所事事。

“在突然之间，我变得非常渴望找到一种收入来源。”弗莱彻回忆道。“因此我回到了原来的大学，找到了一个为技术部门工作的岗位。”

正是在这个工作岗位上，弗莱彻第一次与万维网和Mosaic的“What's New”页面邂逅。

更好的方法

在为斯特灵大学建设一个网络服务器的过程中，弗莱彻意识到，“What's New”页面存在根本上的缺陷。由于网站是以人工方式被添加到这个网页的列表中的缘故，没有什么东西能被用来追踪网站内容的变化。其结果是，许多链接很快就会变得过期或是被错误标记。

“如果你想要看看有什么东西发生了变化，那么就不得不回过头去查看。”弗莱彻在谈及Mosaic的链接时说道。“抱着必须推出一种更好的方法的念头，拥有计算机科学学位的我决定要编写一些东西来改变这种情况。”

弗莱彻所说的“一些东西”就是全世界的第一个“网络爬虫”（web crawler）。弗莱彻把自己的这种发明称作“JumpStation”，他建立起了一个页面索引，能通过“网络爬虫”来对页面进行搜索，这基本上来说是一种自动化的处理程序，能对被其发现的每个网站页面进行访问和索引。这种自动化处理的程序会一直继续下去，直到“网络爬虫”再也找不到东西可以访问时为止。

在十年以后，也就是1993年12月21日，JumpStation就再也找不到可以访问的东西，结果是将2.5万个页面编入索引。而在今天，谷歌已经编入索引的页面数量已经超过了1万亿个。

乔纳森-弗莱彻：被遗忘的搜索引擎之父

JumpStatio诞生几个月以前的“What's New”页面（腾讯科技配图）

搜索的诞生

弗莱彻很快就为这个索引开发出了一种易于导航的搜索工具，将自己的网站嵌入了Mosaic的“What's New”页面，这标志着全世界第一个现代搜索引擎开始运作。

“我会说，他是网络搜索引擎之父。”墨尔本皇家理工大学（Royal Melbourne Instituteof Technology）的马克·桑德森（Mark Sanderson）教授说道，他专门负责研究信息检索的历史。“（在弗莱彻发明第一个网络搜索引擎之前的）很长一段时间里，很明显一直都有计算机在从事搜索工作；在网络诞生以前，当然也已经有搜索引擎存在。然而，是弗莱彻第一个创造了一种拥有现代搜索引擎所有组成部分的搜索引擎。”

但在今天，谷歌的两名联合创始人塞吉·布林（Sergey Brin）和拉里·佩奇（Larry Page）都已经成为家喻户晓的名人，而目前居住在中国香港的弗莱彻却几乎没有因为他为互联网进化作出的贡献而为人所知。

之所以会出现这种情况，或许与他的项目最终被放弃有关。随着JumpStation的成长，这个项目需要的投资越来越大，而这种投资却是斯特灵大学所不愿提供的。“当时JumpStation是在一个共享服务器上运行的。”弗莱彻解释道。“那时没有很大的磁盘空间，而且当时的磁盘很小，价格也很昂贵。”

空间控制

到1994年6月份，JumpStation已经对27.5万个页面进行了索引。空间方面的限制迫使弗莱彻仅对网页的标题进行索引，而不是对网页的全部内容进行索引；但即使是在作出了这种妥协以后，JumpStation也仍旧开始面临着过载的困境。

弗莱彻也同样已不堪重负。“那并非我的本职工作。”他说道。“那时我的工作职责是维持学生实验室的正常运作，并从事一些系统管理和技术方面的杂活儿。”

在当时，弗莱彻得到了一个到东京工作的机会。对他来说，这个工作机会的吸引力大到令人难以抗拒，而斯特灵大学也几乎没有尝试做些什么来挽留他或是挽留JumpStation。

“很明显，在尝试说服他们相信这个项目很有潜力的问题上，我做得很不成功。”弗莱彻说道。“在当时，我做了自己认为是正确的事情（到日本去工作）。但在过去20年时间里，总有那么些时候我会回首这段往事。”

斯特灵大学计算机科学及数学系主任莱斯利·史密斯（Leslie Smith）教授还记得弗莱彻，他承认JumpStation最终“被证明是领先于时代的”，并在接受BBC采访时表示：“斯特灵大学的同仁们都为他能因自己取得的成就而为人所知感到高兴。”

未来展望

尽管弗莱彻对不得不放弃JumpStation项目而感到失望，但他的这种先驱技术在后来却成为了所有网络搜索引擎的基础。

“在1993年时，网络社区的规模非常小。”桑德森教授说道。“在当时，在网上做任何事情的人都会知道JumpStation。”他还补充道：“到1994年年中前后，网络搜索引擎将变得非常重要这件事情已经开始变得明显。谷歌直到1998年才出现，而弗莱彻在1993年就已经做了这件事情。”

在几个星期以前于爱尔兰首都都柏林召开的SIGIR（国际计算机协会主办的国际信息检索大会）上，弗莱彻由于他在网络搜索引擎方面作出的成就而获得了一些知名度。在当时，他曾跟来自于微软、雅虎和谷歌的与会代表进行过小组讨论。但在弗莱彻的言谈中，他所谈论的并非自己以往的成就，而是对未来作出了展望。

“在我看来，网络不会永远存在。”弗莱彻说道。“但是，找到信息的问题则将永远存在，因为对内容进行搜索并找到信息的愿望是独立于媒介以外的。”

对于追随弗莱彻其后建立起网络搜索引擎的人们来说，当前的这种媒介已经让他们赚到了大笔的钞票。但是，弗莱彻这位出生于英格兰自治市斯卡伯勒（Scarborough）的先驱者并不对此感到遗憾。“我的父母以我为骄傲，我的妻子和孩子也是如此。对我来说，这才是无价之宝，所以我感到非常幸福。”
** 最喜欢的一段perl代码 [#B]                                        :@NCEPU:
                         Added: [2018-08-05 周日 03:47]
                         

#+BEGIN_SRC perl

#!/usr/bin/env perl
#===============================================================================
#
#         FILE: accessPeople.pl
#
#        USAGE: ./accessPeople.pl
#
#  DESCRIPTION:
#
#      OPTIONS: ---
# REQUIREMENTS: ---
#         BUGS: ---
#        NOTES: ---
#       AUTHOR: YOUR NAME (),
# ORGANIZATION:
#      VERSION: 1.0
#      CREATED: 2017/12/10 22:03:34
#     REVISION: ---
#===============================================================================

use strict;
use warnings;
use utf8;

my @records;
my @cols = ( 's_name', 'f_name', 'job' );

my $FILE_file_name = 'people.dat';    # output file name

open my $FILE, '<', $FILE_file_name
    or die "$0 : failed to open  output file '$FILE_file_name' : $!\n";
while (<$FILE>) {
    chomp;
    my %rec;
    @rec{@cols} = split /,/;
    push @records, \%rec;
}

close $FILE
    or warn "$0 : failed to close output file '$FILE_file_name' : $!\n";

foreach (@records) {
    print "$_->{f_name} ", "$_->{s_name} ", "is a $_->{job}\n";
}

#+END_SRC





#+BEGIN_EXAMPLE people.dat
Jones, Martha, UNIT
Harkness,JACK,Torchwood
Smith,Sarah Jane, Journalist
#+END_EXAMPLE
** 常用perl解析中文 [#B]                                            :@NCEPU:
                         Added: [2018-08-05 周日 03:55]
                         


#+BEGIN_SRC perl

# 统一形式  '*(<|>|>>):encoding\(\w+\)'

open my( $read_fh), '<:encoding(UTF-8)', $filename;
open my( $write_fh), '>:encoding(UTF-8)', $filename;
open my( $append_fh), '>>:encoding(UTF-8)', $filename;
#+END_SRC


                          #+BEGIN_SRC perl
                             #!/usr/bin/env perl
                             #===============================================================================
                             #
                             #         FILE: analysisFeiji.pl
                             #
                             #        USAGE: ./analysisFeiji.pl  
                             #
                             #  DESCRIPTION: 
                             #
                             #      OPTIONS: ---
                             # REQUIREMENTS: ---
                             #         BUGS: ---
                             #        NOTES: ---
                             #       AUTHOR: Ye Zhao Liang (YZL), yezhaoliang@ncepu.edu.cn
                             # ORGANIZATION: NCEPU
                             #      VERSION: 1.0
                             #      CREATED: 2017/12/19 21:46:42
                             #     REVISION: ---
                             #===============================================================================

                             use strict;
                             use warnings;
                             use utf8;

                             binmode(STDIN,":encoding(gb2312)");
                             binmode(STDOUT,":encoding(gb2312)");

                             # while ( <> ) {
                             #     chomp;
                             #     print $_,"\n";
                             #     last if $_ =~ m/q/xm;
                             # }

                             open(FEIJI,"feiji.txt") or die "can't open the file \n";
                             my $car ="尾翼";

                             binmode(FEIJI,":encoding(gb2312)");
                             # binmode( STDIN,  ':encoding(gbk2312)' );
                             #binmode( FEIJI,  ':encoding(utf8)' );
                             #binmode( STDOUT, ':encoding(gbk2312)' );   
                             #binmode( STDERR, ':encoding(gbk2312)' ); 
                             #while( my $line = <FEIJI>){
                             #my $re = Encode::decode('GB2312','汽车');
                             my $count=1;
                             while( <FEIJI>){
                                 #print "$_ \n" ;
                                 #     print "$_ \n" if $_ =~ /.*$re.*/;
                                 #    Encode::_utf8_on($_);
                                 #    Encode::decode_utf8($_);
                                 #print "$_\n" ;#if $_ =~ m/$car/xm;
                                 #print "$count: $_\n" if $_ =~ m/$car/xm;
                                 #$count +=1;

                                 s/汽车/风力机/g;
                                 print;
                             }

                         #+END_SRC
** perl正则学习 [#B]                                                  :perl:
                         Added: [2018-08-13 周一 11:38]
                         

                         
perl中有一个tr命令，代表代换，任何的编译器也有着代换的概念（代换就是一一代换吗，
在perl中其实就是一个一个字母进行代换

s///其实是模式代换，tr叫做字母代换，不考虑模式

现在编辑器，vim，emacs等对于多文件搜索(配合上fzf，ag等代码、字符搜索工具）,可以很容易进行

很多编辑器内置了正则表达式引擎，比如vim和emacs的:%s///功能,


*** 反向引用

如果想在s"""运算符的第一部分使用反向引用，使用语法\1 \2等
如果相杂第二部分使用反向引用，使用$1,$2

比如 
#+BEGIN_SRC  perl
$string=~ s"(far)(out)" $2 $1"; ====> 'Out far’

$string=' sample examples'; if($string=~m"(amp..) ex\1") {print "matches!\n";}

#+END_SRC
所以s命令进行匹配的时候是有进行两个隐式的赋值工作(很多人没说好这一点，因为比较细)

比如

#+BEGIN_SRC perl

  $string = ' bballball';
  $string =~ s" (b)\1(a...)\1\2" $1$2";

  #让我们详细地看看这个例子。该例完成匹配，但是原因不是太明显。对这个字符串的匹
  #配有五个步骤：
      1)在圆括号中的第一个b匹配字符串的开头，接着将其存放在\1 和$1 中。
      2)\1 于是匹配字符串中的第二个b，因为与b 相等，而第二个字符碰巧是b。
      3)(a..)匹配字符串all且被存在\2 和$2 中。
      4)\1 匹配下一个b。
      5)因为\2等于all所以匹配下一个且是最后三个字符(all)。
      将他们放到一起就得到正则表达式匹配bballball，或者说是整个字符串。既然$1 等于'
      b'，$2 等于all，则整个表达式：

  $string = ' bballball' ;
  $string =~ s" (b)\1(a..)\1\2" $1$2";
  #(在这个例子中)转换为如下代码：
  $string =~ s" (b)b(all)ball" ball";
  #或者用行话讲，用bballball 替换ball。


  一般第一部分替换比较少一些(第二部分可以直接使用)
#+END_SRC


***  scalars

三种内建的数据结构
1. scalars
2. arrays of scalars(arrays)
3. associates arrays of scalars(hashes)


基于scalars的语法规则！


#my  @words   = $_=~/(\S+)/g; 等效于 #my  @words =  /(\S+)/g; 



*** 零宽断言

从假设出发吧！假设存在那么一个位置！我想找到他的右边单词是。。。就用(?=)
我想找打他的左侧单词就用(?<=)

但是该位置可能不存在， 而匹配词也可能不存在，假设有风险!夹逼须果断！

位置坐落于匹配单词物理上的左侧(?=匹配词) (?!匹配词)  ---或者这样说以当前位置角度出发：如果当前位置的右边存在匹配词
位置坐落于匹配单词物理上的右侧(?<=匹配词) (?<!匹配词)---如果当前位置的左边存在该匹配信息(假设存在这个位置)


#+BEGIN_EXAMPLE
   源字符串：<div>a test</div>

   正则表达式：(?<=<div>)[^<]+(?=</div>)
    这个正则的意义就是匹配<div>和</div>标签之间的内容，而不包括<div>和</div>标签本身。

有个问题，是否领款断言的表达式可以匹配呢
   正则表达式：(?=<div>)[^<]+(?=</div>)
#+END_EXAMPLE\b匹配单词边界

\w匹配[a-zA-Z0-9]  \W匹配非\w
\d匹配[0-9] \D匹配非数字
^匹配行字符串开头  $ 匹配行字符串结尾
\A匹配行头  \Z匹配行尾


#+BEGIN_SRC perl
  print "**********************zero width predicting and backslash g**************************************\n";

  my  $divS= "<div> a test </div>               <div> hello  another test</div>";

  #注意这边不适用//,而使用""来代替，避免和html标签</div>冲突
  #$divS =~ m"(?<=<div>)[^<]+(?=</div>)"xm;
  $divS =~ m"((?<=<div>)[^<]+)(?=</div>)"mx;

  print "THe matched string is $1\n";

  while ( $divS =~ m"((?<=<div>)[^<]+)(?=</div>)"mxg ) {
      print "THe matched string is $1\n";
  }


  ## result
  #**********************zero width predicting and backslash g**************************************
  THe matched string is  a test
  THe matched string is  a test
  THe matched string is  hello  another test
#+END_SRC

注意还有一点，正则表达式\< 和\>匹配单词边界(分别匹配the start position of a word and the end position of a word
还有就是命名捕获也会用尖括号！

由于零宽断言，最终只获得一个位置，我们是否可以获取其匹配的内容？多此一举，直接不使用零宽断言不就ok了！！

零宽断言其实也叫作夹逼定理(洛必达法则，嘚瑟的说出来 luo重音 必(重音)达(达平音）

边界本身也是一个夹逼的过程，答案本身也是夹逼的过程，数值计算也是夹逼的过程！人生也是夹逼的过程！
并行： 分别夹逼的过程!
所以一定得把逼夹紧！

**** 正则命名捕获


#+BEGIN_SRC perl
  print "*********************** named capture*************************************\n";

  ## All named capture string are stored in the associative arrays of scalars(hash) named %+
  # So yuu can use $+{name} to reference the value of the captured term.
  my $str = "jack and rose"; 
  if ($str =~ /(?<first>\S+) (and|or) (?<second>\S+)/) { 
      my ($first, $second) = ($+{first}, $+{second}); 
      print "$first\n$second\n";  # jack, rose 
      print "the current \$1 \$2 \$3 is $1 , $2 , $3\n";
  } 

#+END_SRC

#+BEGIN_EXAMPLE


#########*********************** named capture*************************************
jack
rose
the current $1 $2 $3 is jack , and , rose



#+END_EXAMPLE

**** 不捕获


use ?: to stop capturing the content into $number array!
#+BEGIN_SRC perl
  if ($str =~ /(?<first>\S+) (?:and|or) (?<second>\S+)/) { 
      my ($first, $second) = ($+{first}, $+{second}); 
      print "$first\n$second\n";  # jack, rose 
      print "Now  \$1 \$2 \$3 is $1 , $2 , $3\n";
  } 

#+END_SRC


#+BEGIN_EXAMPLE
#*********************** named capture*************************************
jack
rose
Use of uninitialized value $3 in concatenation (.) or string at testArray2.pl line 118.
Now  $1 $2 $3 is jack , rose ,

#+END_EXAMPLE

所以命名捕获其实是让程序多做事情!


*** 两字字符


跟踪一个人并不简单，至少得10个人，如果只有一个人，那么至少要挡住自己的脸


perl有两种字符单元
1. 元字符(\w \b \a \z ^ $ \1 \2 $1 $2 \< \>  a-zA-Z0-9 \s \S \d \D .   + ? {3,5} -) 特殊意义的字符
2. 基本字符a-z A-Z 0-9（字面值）
   
正则表达式的思维！

要想正确使用正则表达式，清楚地了解目标文本是非常重要的


****  字符组和多选结构的区别

字符组(character set)只是针对单个单词，基本可以算是一门独立的微型语言(例如 对于元字符，他们有自己的规定)

而多选结构(alternative)是"正则表达式语言主体(main regular expression language)"的一部分。
多选结构(alternative)可以包括很多字符，但不能超越括号的界限！

gr[ae]y 和 gr(a|e)y虽然一样，但是理念不一样

'^From|Subject|Date:' 查三种类型的信息

'^(From|Subject|Date):'  查询From或者Subject或者Date开头并以冒号结尾的


竖线的本质就是匹配分割两边的任意一个表达式
也就是说括号通常是和竖线合在一起使用的,也就是限制竖线的作用范围！


一般字符组的效率差些，最好用分支结构!
多选项缺点: 没有像字符组那样排除功能，可以匹配任意长度的文本,相当于一个一个选项!


#+BEGIN_SRC perl
  ([\u4e00-\u9fa5\w])\1+


  ([a-zA-Z0-9]+)\1+  查找重复英文
    
  (\w+)\1+
  (\w+)\s\1+    可以查到the the

#+END_SRC



正则表达式包含多个流派！
弄懂正则表达式的工作原理，才是真正理解的关键

学习正则表达式犹如造车一样，是一种艺术形式，而不是仅仅开车（不需要懂得车运行原理）
在造车之前，必须了解汽车的工作原理。

你有开过车，知道怎么用起来就可以了！但是真想开的好，也不一定得精通车的原理！

1. 开车的经验
2. 开车的历史 详细考察正则表达式的流派的主要内容
3. 正则表达式流派重要引擎
4. 更为复杂内容
5. 设置具体的正则引擎
6. 检查具体的产品和模型！
   

***  华氏转为摄氏度


#+BEGIN_SRC perl
  print "**********************huashi ******************************************\n";

  print "Enter a temperature (e.g., 32F, 100C):\n";
  my  $input= <STDIN>; ## 接收用户一行文本
  chomp($input);


  #if ( $input =~ m/^([-+]?[0-9]+)([CF])$/xm ) {
  #此时 $1 保存 数字     $2保存类型
  if ( $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)([CF])$/xm ) {
  #此时 $1 保存 数字和小数点数字    $2保存小数点 $3保存类型
     my $InputNum = $1; ## 数据存储
     my  $type = $3;  ## 保证程序清晰易懂

     my  $celsius;
     my  $fahrenheit;

     if ( $type eq "C" ) {
         #输入为摄氏温度
         $celsius = $InputNum;
         $fahrenheit = ($celsius * 9 /5.0) + 32;
     }
     else {
         $fahrenheit = $InputNum;
         $celsius = ($fahrenheit - 32)*5 / 9.0;
     }

     printf "%.2f C is %.2f F \n", $celsius,$fahrenheit;
  }
  else {
      print "Expecting a number followed by \"C\" or \"F\", \n";
      print "So I don't understand \"$input\". \n";
  }

#+END_SRC


改进写法，支持大小写(也许你更喜欢/i,因为它更简洁，类似\s)，支持小数点!
#+BEGIN_SRC perl
  ##if ( $input =~ m/^([-+]?[0-9]+)([CF])$/xm ) {
  #此时 $1 保存 数字     $2保存类型
  #if ( $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)([CF])$/xm ) {
  #if ( $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([cCfF])$/xm ) {
  if ( $input =~ m/^([-+]?[0-9]+(\.[0-9]*)?)\s*([CF])$/ixm ) {
  ## /i 不区分大小写
  #此时 $1 保存 数字和小数点数字    $2保存小数点 $3保存类型
     my $InputNum = $1; ## 数据存储
     my  $type = $3;  ## 保证程序清晰易懂

     my  $celsius;
     my  $fahrenheit;

     if ( $type eq "C" || $type eq "c" ) {
    # if ( $type =~ m/c/i) {   #或者这种方式更加简洁些！ 伟大的i    伟大的g

         #输入为摄氏温度
         $celsius = $InputNum;
         $fahrenheit = ($celsius * 9 /5.0) + 32;
     }
     else {
         $fahrenheit = $InputNum;
         $celsius = ($fahrenheit - 32)*5 / 9.0;
     }

     printf "%.2f C is %.2f F \n", $celsius,$fahrenheit;
  }
  else {
      print "Expecting a number followed by \"C\" or \"F\", \n";
      print "So I don't understand \"$input\". \n";
  }

#+END_SRC

***  括号三种用法

1. 限定多选方案的范围比如 gr(a|e)y  竖线的作用范围只能在a和e之间，而如果是gra|ey则变成gra和ey两个表达式
2. 分组，比如(wor)fdf(hel)  分组$1 $2
3. 捕获 。。。 也有不捕获比如(?:...)


*** 反斜杠(反斜线)backslash的四种用法

1. \> \< 构成元字符(不同流程构成了不同对应元字符的定义)
2. \w([a-zA-Z0-9] \W([^a-zA-Z0-9] \d([0-9]) \D([^0-9] \s(所有空白字符:空格符、制表符、换行符、
   回车符, 更方便些) \S \A \Z 和字母结合构成元字符, \b单词边界 \B
3. \\ \( \) 去除某些元字符的意义，保存字符特殊含义
4. \t(字表符) \n \r \l 构成特殊孔子字符
   
*** 斜杠(斜线)slash两种用法
1. 斜线用来标记正则表达式的边界 比如m//  s///也可以用m""  m{}等来代替斜线！
2. /和某些字母结合，充当匹配表达式的拓展功能，比如/i表示不区分大小写，/g表示全局匹配行， /m多行匹配 , /x表示正则表达式
   正则表达式可以写成多行的形式，忽略中间的换行符!


***  破折号两种用法

1. 放在character set第一个位置表示破折号意思
2. 放在character set中间某个位置比如[a-z] 表示到（范围的意思）
3. perl -i 表示直接写进文件, -p表示对目标文件每一行进行查找和替换  perl -p -e -i 's/sysread/read/g' file

类似的意思还比如尖角号

****  尖角号三种用法

1. 放在character set第一个位置表示逻辑非
2. 放在character set其他位置表示尖角字面值意思
3. 放在表达式首位类表征匹配要匹配字符串的首位，对应$为尾位
   
而且一般限定尖角和dollar符号可以加快匹配速度

*** 单词的定义

perl和其他语言一样都把数字、字母、下划线当做单词一部分

单词分界符意思：在此位置一侧是单词(例如数字、字母）另一侧不是(例如行的末尾或者数字后面的空格）
一侧如此这般，另一侧如此那般：(是不是类似顺序环视和逆序环视）


*** 栈式测试操作符


#+BEGIN_SRC perl
  #perl 5.10引入栈式操作

  # 5.10以前写法
  if(-r $file and -w _){
      print "hel..";
  }

  # 5.10以后写法
  use 5.010;
  if(-w -r -d -x -o $file){
      print "My directory is readable ,writable, and executable!\n");
  }

  # 靠近$file的先进性判断

  Learning Perl P238回看可能的误用!
#+END_SRC


*** 尖括号的作用(diamond)

通配符匹配所有当前文件夹下pm结尾可以写为 "*.pm"

perl可以使用 glob "*.pm" 获取所有文件，当然也可以使用<"**.pm">获取


这种运用场景也用于文件读取

也就是说diamond（尖括号）既可以表示文件句柄读取又代表文件名通配操作，那么perl又是如何判断取舍？

因为合理的文件句柄必须是严格意义上的Perl标识符，所以如果满足Perl标识符条件的，就作为文件句柄读取，otherwise,..


#+BEGIN_SRC perl
  my @files = <FRED/*>; ## 文件名 通配符
  my @lines = <FRED>; ##文件句柄
  my @lines = <$fred>; #文件句柄
  my $nane = 'FRED';
  my @files = <$name/*>;  #文件名通配操作


  # 唯一例外

  my $name ='FRED';
  my @lines = <$name>; # $name解析为FRED句柄，当做文件句柄! 不要用间接文件句柄！！！！
#+END_SRC


**** 目录句柄

open     ---> opendir
readline ---> readdir
close    ---> closedir



#+BEGIN_SRC perl
      ## file
        my	$letterfile_file_name = 'someFiles.md';		# input file name

        open  my $letterfile, '<', $letterfile_file_name
            or die  "$0 : failed to open  input file '$letterfile_file_name' : $!\n";

        close  $letterfile
            or warn "$0 : failed to close input file '$letterfile_file_name' : $!\n";


      ## directory
        my	$letterfile_direcotry_name = 'Directory/';		# input file name

        opendir  my $letterfile, '<', $letterfile_direcotry_name
            or die  "$0 : failed to open  input file '$letterfile_direcotry_name' : $!\n";

    while($name = readdir $letterfile_direcotry_name){
        next unless $name=~ /\.pm$/;
  next if $name=~ /^\./;
next if $name eq '.' or $name eq '..';
    }
        closedir  $letterfile
            or warn "$0 : failed to close input file '$letterfile_direcotry_name' : $!\n";

#+END_SRC


****  File::Spec::Functions



#+BEGIN_SRC perl
  #为了让程序健壮和可移植 使用File::Spec::Functions

  use File::Spec::Functions;

  opendir my $somedir,$dirname or die "Cannot open$dirnmame:$!";
  while(my $name = readdir $somedir){

      next if $name =~ /^\./; # 跳过点号开头的文件
      $name =catfile($dirname,$name); #拼合完整路径
      next unless -f $name and -r $name; #如果没有拼合路径，文件测试操作符会在当前目录下查找文件，而不是在$dirname指定目录下。
  }
#+END_SRC


**** 递归访问目录 Fild::Find


File::Find:Rule和File::Finder都是基于File::Find

**** 删除文件unlink

unlink 'slate'; #会把当期目录下的slate文件扔进粉碎纸机，消失在系统中
unlink glob '*.o';
unlink <'*.o'>;


my $successful = unlink "slate","bedrock","java";
print "I deleted $successful file(s) just now\n"; #如果是0，表示没有删除任何文件



* Sun set(光符集 sun character set)

sunset日落（日落字符)
